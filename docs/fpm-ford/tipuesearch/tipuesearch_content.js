var tipuesearch = {"pages":[{"title":" easy ","text":"easy Developer Info John Doe","tags":"home","loc":"index.html"},{"title":"M_factor.f90 – easy","text":"Contents Modules M_factor Source Code M_factor.f90 Source Code !> !!##NAME !!      M_factor(3fm) - [M_factor::INTRO] module for least common multiple, greatest common divisor, and prime factors !!##SYNOPSIS !! !! !!    least_common_multiple     least common multiple of two integers (i,j) or !!                              integer array m(:|:,:|:,:,:) !!    greatest_common_divisor   greatest common divisor of two integers (i,j) or !!                              integer array m(:|:,:|:,:,:) !!    prime_factors             prime factors of a number !!    i_is_prime                determine if an integer is a prime !! !!##DESCRIPTION !!    This module is a collection of procedures that perform common functions !!    found in arithmetic and number theory such as Least Common Multiples, !!    Greatest Common Divisors, and Prime Factors of INTEGER variables. !!    The INTEGER values are typically limited to values up to the magnitude !!    (2**31)-1= 2147483647. !! !!##PRIMES !!    Date     10/06/97 at 12:47:29 !!    From     Doctor Rob !!    Subject  Re: The number 1 and zero !! !!    One is neither a prime nor a composite number. A prime number is one !!    with exactly two positive divisors, itself and one. One has only one !!    positive divisor. It cannot be written as a product of two factors, !!    neither of which is itself, so one is also not composite. It falls !!    in a class of numbers called units. These are the numbers whose !!    reciprocals are also whole numbers. !! !!    Zero is not a prime or a composite number either. Zero has an infinite !!    number of divisors (any nonzero whole number divides zero). It cannot !!    be written as a product of two factors, neither of which is itself, so !!    zero is also not composite. It falls in a class of numbers called !!    zero-divisors. These are numbers such that, when multiplied by some !!    nonzero number, the product is zero. !! !!    The most important fact of multiplication of integers is called the !!    Fundamental Theorem of Arithmetic. It says that every whole number !!    greater than one can be written *uniquely* (except for their order) as !!    the product of prime numbers. This is so important that we tailor our !!    idea of what a prime number is to make it true. If 1 were a prime !!    number, this would be false, since, for example, !! !!       7 = 1*7 = 1*1*7 = 1*1*1*7 = ..., !! !!    and the uniqueness would fail. !! !!##EXAMPLES !! !!     The individual man(1) pages for each procedure contain examples and !!     a full description of the procedure parameters. !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_factor private !----------------------------------------------------------------------------------------------------------------------------------- public prime_factors ! prime factors of a number public i_is_prime ! determine if an integer is prime or not !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), parameter :: ident1 = '@(#)M_factor::least_common_multiple(3f): function finds LCM for (i,j)|m(:)|m(:,:)|m(:,:,:)' public least_common_multiple private lcm ! least common multiple of two integers private lcm_vector ! least common multiple of integer array m(:) private lcm_matrix ! least common multiple of integer array m(:,:) private lcm_cuboid ! least common multiple of integer cuboid m(:,:,:) interface least_common_multiple module procedure lcm module procedure lcm_vector module procedure lcm_matrix module procedure lcm_cuboid end interface !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), parameter :: ident2 = '@(#)M_factor::greatest_common_divisor(3f): function finds GCD for (i,j)|m(:)|m(:,:)|m(:,:,:)\"' public greatest_common_divisor public gcd ! greatest common divisor of two integers public gcd_2 ! greatest common divisor of two integers private gcd_vector ! greatest common divisor of integer vector m(:) private gcd_matrix ! greatest common divisor of integer array m(:,:) private gcd_cuboid ! greatest common divisor of integer cuboid m(:,:,:) interface greatest_common_divisor module procedure gcd module procedure gcd_vector module procedure gcd_matrix module procedure gcd_cuboid end interface !----------------------------------------------------------------------------------------------------------------------------------- contains !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!    least_common_multiple(3f) - [M_factor] Least common multiple of two integers !!                                or vector m(:), matrix m(:,:) or cuboid m(:,:,:) !!                                (LICENSE:MIT) !!##SYNOPSIS !! !!    use, intrinsic :: iso_fortran_env, only : int64 !!     integer function least_common_multiple(i,j) !!     integer,intent(in):: i,j !!      or !!    integer function(kind=int32) least_common_multiple(m) !!     integer,intent(in):: m(:) !!      or !!     integer,intent(in):: m(:,:) !!      or !!     integer,intent(in):: m(:,:,:) !! !!##DESCRIPTION !!    From Wikipedia, the free encyclopedia: !! !!    In arithmetic and number theory, the least common multiple (also !!    called the lowest common multiple or smallest common multiple) of !!    two integers a and b, usually denoted by LCM(a, b), is the smallest !!    positive integer that is divisible by both a and b. Since division !!    of integers by zero is undefined, this definition has meaning only !!    if a and b are both different from zero. However, some authors define !!    lcm(a,0) as 0 for all a, which is the result of taking the LCM to be !!    the least upper bound in the lattice of divisibility. !! !!    The LCM is familiar from grade-school arithmetic as the \"lowest common !!    denominator\" (LCD) that must be determined before fractions can be !!    added, subtracted or compared. The LCM of more than two integers !!    is also well-defined: it is the smallest positive integer that is !!    divisible by each of them. !! !!##EXAMPLE !! !!   Sample Program: !! !!    program demo_lcm !!    use M_factor, only : lcm=>least_common_multiple !!    implicit none !!       write(*,*)'SCALAR:' !!          call writeit(10,24,120) !!          call writeit(15,30,30) !!          call writeit(-15,-30,30) !!          call writeit(15,-30,30) !!          call writeit(-15,30,30) !! !!       write(*,*)'VECTOR:' !!          call writeit_v([10,24],120) !!          call writeit_v([15,30],30) !!          call writeit_v([-15,-30],30) !!          call writeit_v([5,-15,-40],120) !!          call writeit_v([2,3,4,5],60) !!       write(*,*)'Special cases:' !!          call writeit_v([15,0],0) !!          call writeit_v([-15,0],0) !!          call writeit_v([0],0) !!          call writeit_v([-10],10) !!          call writeit_v([22],22) !!          call writeit_v([0,0],0) !!          call writeit_v([0,0,0,0,0],0) !!          call writeit_v([0,0,0,-1,0],0) !!          call writeit_v([0,0,0,33,0,3,11],0) !!       contains !! !!       subroutine writeit(ii,jj,answer) !!       integer,intent(in) :: ii,jj !!       integer,intent(in) :: answer !!          write(*,'(\"  For lcm(\",I0,\",\",I0,\") the value is \",I0,\" which is \",L1)')& !!             & ii,jj,lcm(ii,jj),lcm(ii,jj).eq.answer !!       end subroutine writeit !! !!       subroutine writeit_v(array,answer) !!       integer,intent(in) :: array(:) !!       integer,intent(in) :: answer !!          write(*,'(\"  For lcm([\",*(i0:,1x))',advance='no')array !!          write(*,'(\"]) the value is \",i0,\" which is \",L1)') & !!             & lcm(array),lcm(array).eq.answer !!       end subroutine writeit_v !! !!    end program demo_lcm !! !!   Expected results: !! !!     > SCALAR: !!     >  For lcm(10,24) the value is 120 which is T !!     >  For lcm(15,30) the value is 30 which is T !!     >  For lcm(-15,-30) the value is 30 which is T !!     >  For lcm(15,-30) the value is 30 which is T !!     >  For lcm(-15,30) the value is 30 which is T !!     > VECTOR: !!     >  For lcm([10 24]) the value is 120 which is T !!     >  For lcm([15 30]) the value is 30 which is T !!     >  For lcm([-15 -30]) the value is 30 which is T !!     >  For lcm([5 -15 -40]) the value is 120 which is T !!     >  For lcm([2 3 4 5]) the value is 60 which is T !!     > Special cases: !!     >  For lcm([15 0]) the value is 0 which is T !!     >  For lcm([-15 0]) the value is 0 which is T !!     >  For lcm([0]) the value is 0 which is T !!     >  For lcm([-10]) the value is 10 which is T !!     >  For lcm([22]) the value is 22 which is T !!     >  For lcm([0 0]) the value is 0 which is T !!     >  For lcm([0 0 0 0 0]) the value is 0 which is T !!     >  For lcm([0 0 0 -1 0]) the value is 0 which is T !!     >  For lcm([0 0 0 33 0 3 11]) the value is 0 which is T !! !!##METHOD !!    Reduction by the greatest common divisor !! !!    The following formula reduces the problem of computing the least !!    common multiple to the problem of computing the greatest common divisor !!    (GCD), also known as the greatest common factor: !! !!     lcm(a,b) = |a*b| / gcd(a,b) !! !!    This formula is also valid when exactly one of a and b is 0, since !!    gcd(a, 0) = |a|. (However, if both a and b are 0, this formula would !!    cause division by zero; lcm(0, 0) = 0 is a special case. !!##AUTHOR !!    John S. Urban !!##LICENSE !!    MIT License !----------------------------------------------------------------------------------------------------------------------------------- integer function lcm ( i , j ) use , intrinsic :: iso_fortran_env , only : int64 implicit none ! ident_1=\"@(#)M_factor::lcm(3fp): least common multiple of two integers\" integer , intent ( in ) :: i , j integer ( kind = int64 ) :: lcm_big if ( i . eq . 0. and . j . eq . 0 ) then lcm = 0 else ! if default integer is 32-bit integer ! would be limited to input values < sqrt((2**31)-1) if did not increase from default kind, assuming default <= int64 lcm_big = abs ( int ( i , kind = int64 ) * int ( j , kind = int64 ) ) / gcd ( i , j ) if ( lcm_big . gt . huge ( 0 )) then write ( * , * ) '*lcm* result larger than a standard integer =' , lcm_big stop 1 else lcm = lcm_big endif endif end function lcm !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!    lcm_vector(3fp) - least common multiple of integer vector m(:) !! !!##SYNOPSIS !! !!    integer function lcm_vector(m) !! !!     integer,intent(in)  :: m(:) !! !!##DESCRIPTION !!    Find the Least Common Denominator of an INTEGER vector M(:). !----------------------------------------------------------------------------------------------------------------------------------- integer function lcm_vector ( m ) implicit none ! ident_2=\"@(#)M_factor::lcm_vector(3fp): least common multiple of integer array m(:)\" integer , intent ( in ) :: m (:) integer :: i integer :: vsize vsize = size ( m ) select case ( vsize ) case (: 0 ) ! special case for null input list lcm_vector = 0 ! return 0 ; optionally should fail case default lcm_vector = m ( 1 ) ! so first call has two defined values duplicate first value do i = 1 , vsize ! lcm_vector = lcm ( m ( i ), lcm_vector ) enddo end select end function lcm_vector !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!    lcm_matrix(3fp) - least common multiple of integer array m(:,:) !! !!##SYNOPSIS !! !!    integer function lcm_matrix(m) !! !!     integer,intent(in)  :: m(:,:) !! !!##DESCRIPTION !!    Find the Least Common Denominator of an INTEGER matrix M(:,:). !----------------------------------------------------------------------------------------------------------------------------------- integer function lcm_matrix ( m ) implicit none ! ident_3=\"@(#)M_factor::lcm_matrix(3fp):least common multiple of integer matrix m(:,:)\" integer , intent ( in ) :: m (:,:) lcm_matrix = lcm_vector ( reshape ( m ,[ size ( m )])) end function lcm_matrix !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!    lcm_cuboid(3fp) - least common multiple of integer cuboid m(:,:,:) !! !!##SYNOPSIS !! !!    integer function lcm_cuboid(m) !! !!     integer,intent(in)  :: m(:,:,:) !! !!##DESCRIPTION !!    Find the Least Common Denominator of an INTEGER cuboid M(:,:,:). !----------------------------------------------------------------------------------------------------------------------------------- integer function lcm_cuboid ( m ) implicit none ! ident_4=\"@(#)M_factor::lcm_cuboid(3fp):least common multiple of integer cuboid m(:,:,:)\" integer , intent ( in ) :: m (:,:,:) lcm_cuboid = lcm_vector ( reshape ( m ,[ size ( m )])) end function lcm_cuboid !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!    greatest_common_divisor(3f) - [M_factor] calculate greatest common divisor of !!                                  two integers or vector m(:), !!                                  matrix m(:,:) or cuboid m(:,:,:) !!                                  (LICENSE:MIT) !! !!##SYNOPSIS !! !!   The function is generic and may take either two integers or an integer !!   vector, matrix, or cuboid. !! !!    integer function greatest_common_divisor(i,j) !!    integer,intent(in)::  i,j !!      or !!    integer function greatest_common_divisor(m) !!    integer,intent(in)::  m(:) !!     or !!    integer,intent(in)::  m(:,:) !!     or !!    integer,intent(in)::  m(:,:,:) !! !!##DESCRIPTION !! !!  The method used is the Euler algorithm; that for two integers ... !! !!    1. Subtract the 2nd number (N) as many times as possible !!       from the 1st one (M) and save remainder using FORTRAN !!       function MOD. !! !!    2. Test if remainder is equal to zero, if so GCD = N. !!       If not replace M with N and N with remainder and !!       proceed with step 1. !! !!    3. Repeat both steps until remainder becomes zero. !! !!##EXAMPLE !! !! !!  Sample program: !! !!    program demo_greatest_common_divisor !!    use M_factor, only : gcd=>greatest_common_divisor !!    implicit none !!    integer, allocatable :: matrix(:,:) !!       ! SCALAR: !!          call writeit(26,130,26) !!          call writeit(91,390,13) !!          call writeit(-91,390,13) !!          call writeit(91,-390,13) !!          call writeit(-41,-43,1) !!          call writeit(-20,-10,10) !!          call writeit(20,10,10) !!       ! VECTOR: !!          call writeit_v([26,130,91,390],13) !!          call writeit_v([5,7,11,13,17,19,23,29,31,37,41,43,47],1) !!          call writeit_v([-20,-10,0],10) !!          call writeit_v([20,10,0],10) !!          call writeit_v([26,130],26) !!          call writeit_v([91,390],13) !!          call writeit_v([-91,390],13) !!          call writeit_v([91,-390],13) !!          call writeit_v([-41,-43],1) !!          call writeit_v([-20,-10],10) !!          call writeit_v([20,10],10) !!       ! MATRIX: !!          matrix=reshape([ 11,22,33,44,55,66],[2,3]) !!          call write_matrix(matrix,11) !!          matrix=reshape([5,7,11,13,17,19,23,29,31,37,41,43,47],[13,1]) !!          call write_matrix(matrix,1) !!          matrix=reshape([40,80,120,160],[2,2]) !!          call write_matrix(matrix,40) !! !!       contains !! !!       subroutine writeit(ii,jj,answer) !!       integer,intent(in) :: ii,jj !!       integer,intent(in) :: answer !!          write(*,'(\"gcd([\",i0,\",\",i0,\"]) produces \",i0,\" which is \",l1)') & !!               & ii,jj,gcd(ii,jj),gcd(ii,jj).eq.answer !!       end subroutine writeit !! !!       subroutine writeit_v(vector,answer) !!       integer,intent(in) :: vector(:) !!       integer,intent(in) :: answer !!          write(*,'(\"gcd([\",*(i0:,\",\"))',advance='no')vector !!          write(*,'(\"]) produces \",i0,\" which is \",l1)') & !!               & gcd(vector),gcd(vector).eq.answer !!       end subroutine writeit_v !! !!       subroutine write_matrix(matrix,answer) !!       integer,intent(in) :: matrix(:,:) !!       integer,intent(in) :: answer !!          write(*,*)'MATRIX SHAPE:',size(matrix,dim=1),size(matrix,dim=2) !!          write(*,'(\"gcd([\",*(i0:,\",\"))',advance='no')matrix !!          write(*,'(\"]) produces \",i0,\" which is \",l1)') & !!               & gcd(matrix),gcd(matrix).eq.answer !!       end subroutine write_matrix !! !!    end program demo_greatest_common_divisor !!  Expected Output: !! !!    >  SCALAR: !!    > gcd([26,130]) produces 26 which is T !!    > gcd([91,390]) produces 13 which is T !!    > gcd([-91,390]) produces 13 which is T !!    > gcd([91,-390]) produces 13 which is T !!    > gcd([-41,-43]) produces 1 which is T !!    > gcd([-20,-10]) produces 10 which is T !!    > gcd([20,10]) produces 10 which is T !!    >  VECTOR: !!    > gcd([26,130,91,390]) produces 13 which is T !!    > gcd([5,7,11,13,17,19,23,29,31,37,41,43,47]) produces 1 which is T !!    > gcd([-20,-10,0]) produces 10 which is T !!    > gcd([20,10,0]) produces 10 which is T !!    > gcd([26,130]) produces 26 which is T !!    > gcd([91,390]) produces 13 which is T !!    > gcd([-91,390]) produces 13 which is T !!    > gcd([91,-390]) produces 13 which is T !!    > gcd([-41,-43]) produces 1 which is T !!    > gcd([-20,-10]) produces 10 which is T !!    > gcd([20,10]) produces 10 which is T !!    >  MATRIX: !!    >  MATRIX SHAPE:           2           3 !!    > gcd([11,22,33,44,55,66]) produces 11 which is T !!    >  MATRIX SHAPE:          13           1 !!    > gcd([5,7,11,13,17,19,23,29,31,37,41,43,47]) produces 1 which is T !!    >  MATRIX SHAPE:           2           2 !!    > gcd([40,80,120,160]) produces 40 which is T !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    MIT License !> !! FUNCTION:    gcd(M,N) !! DATE:        30-Aug-2015 !!##VERSION:     V1.0.0 !! MODIFIED BY: John S. Urban !! PURPOSE:     Computes the Greatest Common Divisor of two integers. !!              If M=N=0 then the GCD is defined to be zero. !!              IE. GCD is a factor of M and N and GCD is the largest such factor. !! REFERENCES:  Euler algorithm (slow) !! UUID:        UUID=de642070-4ecd-414b-895c-578ea7547948 !----------------------------------------------------------------------------------------------------------------------------------- function gcd ( m , n ) result ( answer ) implicit none ! ident_5=\"@(#)M_factor::gcd(3fp): compute greatest common divisor of two integers\" integer , intent ( in ) :: m , n integer :: answer !----------------------------------------------------------------------------------------------------------------------------------- integer :: irest intrinsic :: mod , iabs integer :: ifirst !----------------------------------------------------------------------------------------------------------------------------------- ifirst = iabs ( m ) answer = iabs ( n ) if ( answer . eq . 0 ) then answer = ifirst else do irest = mod ( ifirst , answer ) if ( irest == 0 ) exit ifirst = answer answer = irest enddo answer = iabs ( answer ) endif end function gcd !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !----------------------------------------------------------------------------------------------------------------------------------- integer function gcd_2 ( m , n ) implicit none integer , intent ( in ) :: m , n integer :: answer , ifirst , itemp answer = m ifirst = n do if ( ifirst . eq . 0 ) exit itemp = answer answer = ifirst ifirst = mod ( itemp , ifirst ) enddo gcd_2 = iabs ( answer ) end function gcd_2 !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()- !----------------------------------------------------------------------------------------------------------------------------------- integer function gcd_vector ( m ) implicit none ! ident_6=\"@(#)M_factor::gcd_vector(3fp):greatest common divisor of integer vector m(:)\" integer , intent ( in ) :: m (:) integer :: vsize integer :: i vsize = size ( m ) if ( vsize . gt . 0 ) then gcd_vector = m ( 1 ) TILLONE : do i = 1 , vsize gcd_vector = gcd ( gcd_vector , iabs ( m ( i ))) if ( gcd_vector . eq . 1 ) exit TILLONE enddo TILLONE else gcd_vector = 0 endif end function gcd_vector !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- integer function gcd_matrix ( m ) implicit none ! ident_7=\"@(#)M_factor::gcd_matrix(3fp):greatest common divisor of integer matrix array m(:,:)\" integer , intent ( in ) :: m (:,:) integer :: i , j if ( size ( m ). gt . 0 ) then gcd_matrix = m ( 1 , 1 ) OUTER : do j = 1 , size ( m , dim = 2 ) INNER : do i = 1 , size ( m , dim = 1 ) gcd_matrix = gcd ( gcd_matrix , iabs ( m ( i , j ))) if ( gcd_matrix . eq . 1 ) exit OUTER enddo INNER enddo OUTER else gcd_matrix = 0 endif end function gcd_matrix !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- integer function gcd_cuboid ( m ) implicit none ! ident_8=\"@(#)M_factor::gcd_cuboid(3fp):greatest common divisor of integer cuboid m(:,:,:)\" integer , intent ( in ) :: m (:,:,:) gcd_cuboid = gcd_vector ( reshape ( m ,[ size ( m )])) end function gcd_cuboid !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!    i_is_prime(3f) - [M_factor] Determine if a number is prime using Sieve of Erasthosthenes !!    (LICENSE:???) !!##SYNOPSIS !! !!    function i_is_prime ( n ) !! !!     integer,intent(in) :: n !! !!##DESCRIPTION !!    A simple, unoptimized sieve of Erasthosthenes is used to check whether !!    N can be divided by any integer between 2 and SQRT(N). !! !!##VERSION !!    29 November 1998 !! !!##AUTHOR !!    John Burkardt !! !!##PARAMETERS !!    n       Input, integer N, the integer to be tested. !!##RETURNS !!    Output  logical I_IS_PRIME(3f) is TRUE if N is prime, and FALSE !!            otherwise. Note that negative numbers and 0 are not !!            considered prime. !!##EXAMPLE !! !!   sample program !! !!    program demo_i_is_prime !!    use M_factor, only: i_is_prime !!    implicit none !!    integer  :: i !!    integer  :: icount=0 !!    integer  :: isum=0 !!    integer,parameter :: n= 10000 !!    do i=2, n !!       if(i_is_prime(i))then !!          icount=icount+1 !!          isum=isum+i !!          write(*,*)icount,i !!       endif !!    enddo !!    write(*,*)'number of primes between 2 and ',n,' is ',icount !!    write(*,*)'sum of primes between 2 and ',n,' is ',isum !!    write(*,*)i_is_prime([4,6,8,9,10,12,14,15,16,18]) !!    write(*,*)all(.not.i_is_prime([4,6,8,9,10,12,14,15,16,18])) !!    write(*,*)any(.not.i_is_prime([4,6,8,9,10,12,14,15,16,18])) !!    end program demo_i_is_prime !! end program demo_i_is_prime !=================================================================================================================================== pure elemental function i_is_prime ( n ) implicit none ! ident_9=\"@(#)M_factor::i_is_prime(3f): reports whether an integer is prime\" integer , intent ( in ) :: n integer :: i logical :: i_is_prime !======= compiler bug !*!FINDPRIME: block !======= compiler bug if ( n <= 0 ) then i_is_prime = . false . else if ( n <= 3 ) then i_is_prime = . true . else do i = 2 , int ( sqrt ( real ( n ))) if ( mod ( n , i ) == 0 ) then i_is_prime = . false . !======= compiler bug !*!exit FINDPRIME !======= compiler bug goto 100 endif enddo i_is_prime = . true . endif !======= compiler bug !*!endblock FINDPRIME 100 continue !======= compiler bug end function I_IS_PRIME !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!    prime_factors(3f) - [M_factor] decompose a number into its prime factors !!##SYNOPSIS !! !!    call prime_factors(number,nprm,iprm,iexp[,verbose]) !! !!     integer, intent(in)          :: number !!     integer, intent(out)         :: nprm !!     integer, intent(out)         :: iprm(:) !!     integer, intent(out)         :: iexp(:) !!     logical, intent(in),optional :: verbose !!##DESCRIPTION !! !!    1. Upon return from PRIME_FACTORS, !! !!            NUMBER = IPRM(1)**IEXP(1) * IPRM(2)**IEXP(2) * ... !!                     *IPRM(NPRM)**IEXP(NPRM) !! !!    2. A number represented by a (single-precision) INTEGER !!       value on the VMS VAX cluster can have at most 9 distinct !!       prime factors. On machines where the maximum integer is !!       larger than 2**31 - 1, IPRM and IEXP would, in general, !!       have to be dimensioned larger since larger numbers may !!       have more than 9 distinct prime factors. !!##OPTIONS !! !!    NUMBER   INTEGER constant or variable, number to be decomposed into !!             prime factors. NUMBER .ge. 2. !!             For 32-bit integers NUMBER <= 2147483647 !!    NPRM     INTEGER variable, will contain the number of distinct prime !!             factors of the number. !!    IPRM     INTEGER array of size at least 9, will contain the prime !!             factors of the number. !!    IEXP     INTEGER array of size at least 9, will contain the !!             exponents of the corresponding prime factors. !!    verbose  optional LOGICAL constant or variable, controls printing !!             of results. !! !!              o false - Results are not printed. !!              o true - Results are printed. !!##EXAMPLE !! !! !!  Sample program: !! !!    program demo_prime_factors !!    use M_factor, only : prime_factors !!    implicit none !!       integer  :: number !!       integer  :: iexp(10), iprm(10), nprm !!       logical  :: verbose=.true. !!       integer  :: ios !!       do !!         write(*,'(a)', advance='no') ' Enter number to be factored: ' !!         read(*,*,iostat=ios,end=999) number !!         if(ios.eq.0)then !!            call prime_factors(number, nprm, iprm, iexp, verbose) !!         endif !!       enddo !!    999 continue !!    end program demo_prime_factors !! !! !!##PEDIGREE !!    o Coded at Madison Academic Computing Center, !!      University of Wisconsin, Madison !!    o FORTRAN 77 Version 1988.09 !!    o Code converted using TO_F90 by Alan Miller, 2000-07-14T11:42:45 !!    o Fortran 2003 version 20160918 by John S. Urban !----------------------------------------------------------------------------------------------------------------------------------- subroutine prime_factors ( number , nprm , iprm , iexp , verbose ) implicit none ! ident_10=\"@(#)M_factor::prime_factors(3f):decompose a number into its prime factors\" integer , intent ( in ) :: number ! number to factor integer , intent ( out ) :: nprm ! number of distinct prime factors integer , intent ( out ) :: iprm (:) ! distinct prime factors found, assumed dimensioned to at least 9 integer , intent ( out ) :: iexp (:) ! exponents of the corresponding prime factors in IPRM logical , intent ( in ), optional :: verbose ! .false. no printing; .true. print results !----------------------------------------------------------------------------------------------------------------------------------- !--------LOCAL VARIABLES integer :: div , indx , ii , j , n , offset , olddiv , quo , rem !---------data to obtain trial divisors 2, 3, 5, 7 and all higher numbers not divisible by 2, 3, 5, 7. integer , parameter :: base ( 52 ) = ( / & 211 , 209 , 199 , 197 , 193 , 191 , 187 , 181 , 179 , 173 , 169 , 167 , 163 , & 157 , 151 , 149 , 143 , 139 , 137 , 131 , 127 , 121 , 113 , 109 , 107 , 103 , & 101 , 97 , 89 , 83 , 79 , 73 , 71 , 67 , 61 , 59 , 53 , 47 , 43 , & 41 , 37 , 31 , 29 , 23 , 19 , 17 , 13 , 11 , 7 , 5 , 3 , 2 / ) !--------FORMAT TEMPLATE logical :: verbose_local !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( verbose )) then verbose_local = verbose else verbose_local = . false . endif !--------CHECK NUMBER.  MUST BE .GE. 2 if ( number < 2 ) then !--------ERROR, ISSUE MESSAGE AND TAKE ERROR EXIT. write ( * , \"(' *** ERROR IN PRIME_FACTORS, NUMBER =', i12, ', NUMBER MUST BE >= 2')\" ) number nprm = 0 return endif !--------INITIALIZATIONS. j = 0 n = number olddiv = 0 offset = 0 indx = 53 !--------GET NEXT TRIAL DIVISOR. do indx = indx - 1 if ( indx <= 0 ) then indx = 48 offset = offset + 210 endif div = offset + base ( indx ) !--------TEST TRIAL DIVISOR. do quo = n / div rem = n - quo * div if ( rem /= 0 ) exit !--------FACTOR FOUND, ZERO REMAINDER. n = quo if ( div <= olddiv ) then !--------MULTIPLE FACTOR. iexp ( j ) = iexp ( j ) + 1 cycle endif !--------NEW FACTOR. j = j + 1 iprm ( j ) = div iexp ( j ) = 1 olddiv = div enddo !--------NOT A FACTOR, POSITIVE REMAINDER.  CHECK DIVISOR SIZE. if ( div >= quo ) exit enddo !--------FINISHED, WHAT ISN'T FACTORED IS A PRIME (OR 1). if ( n > 1 ) then j = j + 1 iexp ( j ) = 1 iprm ( j ) = n endif nprm = j if ( verbose_local ) then !--------PRINT RESULTS IF REQUESTED. if ( nprm /= 1 . or . iexp ( 1 ) /= 1 ) then !--------NUMBER IS COMPOSITE write ( * , \"( t3, i0, ' factors as ')\" , advance = 'no' ) number !*! write (*,'(*(\"(\",i0,\"**\",i0,\")\":,\"*\"))') (iprm(ii),iexp(ii),ii=1,nprm) do ii = 1 , nprm if ( iexp ( ii ). eq . 1 ) then write ( * , '(i0)' , advance = 'no' ) iprm ( ii ) else write ( * , '(\"(\",i0,\"**\",i0,\")\")' , advance = 'no' ) iprm ( ii ), iexp ( ii ) endif if ( ii . eq . nprm ) then write ( * , * ) else write ( * , '(\"*\")' , advance = 'no' ) endif enddo else write ( * , \"( t3, i0, ' IS A PRIME NUMBER' )\" ) number !--------NUMBER IS PRIME endif endif end subroutine prime_factors !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- end module M_factor !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/m_factor.f90.html"},{"title":"primes.f90 – easy","text":"Contents Programs primes Source Code primes.f90 Source Code program primes !(LICENSE:MIT) use M_factor , only : i_is_prime implicit none integer :: i integer :: icount = 0 integer , parameter :: n = huge ( 0 ) do i = 2 , n if ( i_is_prime ( i )) then icount = icount + 1 write ( * , * ) icount , i endif enddo end program primes","tags":"","loc":"sourcefile/primes.f90.html"},{"title":"ulam.f90 – easy","text":"Contents Programs ulam Source Code ulam.f90 Source Code program ulam implicit none integer , parameter :: nsize = 49 integer :: i , j , n , x , y integer :: a ( nsize * nsize ) = ( / ( i , i = 1 , nsize * nsize ) / ) character ( 1 ) :: spiral ( nsize , nsize ) = \" \" character ( 2 ) :: sstr character ( 10 ) :: fmt n = 1 x = nsize / 2 + 1 y = x if ( isprime ( a ( n ))) spiral ( x , y ) = \"O\" n = n + 1 do i = 1 , nsize - 1 , 2 do j = 1 , i x = x + 1 if ( isprime ( a ( n ))) spiral ( x , y ) = \"O\" n = n + 1 end do do j = 1 , i y = y - 1 if ( isprime ( a ( n ))) spiral ( x , y ) = \"O\" n = n + 1 end do do j = 1 , i + 1 x = x - 1 if ( isprime ( a ( n ))) spiral ( x , y ) = \"O\" n = n + 1 end do do j = 1 , i + 1 y = y + 1 if ( isprime ( a ( n ))) spiral ( x , y ) = \"O\" n = n + 1 end do end do do j = 1 , nsize - 1 x = x + 1 if ( isprime ( a ( n ))) spiral ( x , y ) = \"O\" n = n + 1 end do write ( sstr , \"(i0)\" ) nsize fmt = \"(\" // sstr // \"(a,1x))\" do i = 1 , nsize write ( * , fmt ) spiral (:, i ) end do contains function isprime ( number ) logical :: isprime integer , intent ( in ) :: number integer :: i if ( number == 2 ) then isprime = . true . else if ( number < 2 . or . mod ( number , 2 ) == 0 ) then isprime = . false . else isprime = . true . do i = 3 , int ( sqrt ( real ( number ))), 2 if ( mod ( number , i ) == 0 ) then isprime = . false . exit end if end do end if end function end program","tags":"","loc":"sourcefile/ulam.f90.html"},{"title":"factors.f90 – easy","text":"Contents Programs find_prime_factors Subroutines help_usage help_version Source Code factors.f90 Source Code program find_prime_factors Use M_factor , only : prime_factors ! prime number factoring routine use M_kracken , only : kracken , igets , lget , iget ! command line parsing implicit none integer :: iexp ( 10 ), iprm ( 10 ), nprm , number integer :: ios integer :: i integer , allocatable :: values (:) logical :: verbose = . true . integer :: istart = 0 integer :: iend = 0 call kracken ( 'factors' , '-help F -version F -verbose F -start 0 -end -1' ) ! crack command line options call help_usage ( lget ( 'factors_help' )) ! if help text requested display it and quit call help_version ( lget ( 'factors_version' )) ! if version information requested display it and quit values = igets ( 'factors_oo' ) ! get numbers from command line verbose = lget ( 'factors_verbose' ) ! get start and end of any range specified istart = iget ( 'factors_start' ) ! get start and end of any range specified iend = iget ( 'factors_end' ) if ( iend . gt . 0. and . istart . le . 0 ) then ! if iend specified but not istart set istart to 2 call printme ( 2 , iend ) elseif ( istart . gt . 0. and . iend . le . 0 ) then ! if istart is specified but iend is not, set iend to biggest integer call printme ( istart , huge ( 0 )) else call printme ( istart , iend ) endif if ( size ( values ). eq . 0. and .( iend - istart . le . 0 )) then ! if did not print a range and no number specified prompt for values do !!write(*, '(a)', advance='no') ' Enter number to be factored: ' read ( * , * , iostat = ios ) number if ( is_iostat_end ( ios )) then exit elseif ( ios . ne . 0 ) then cycle endif call printme ( number , number ) enddo else ! numbers are on command line do i = 1 , size ( values ) call printme ( values ( i ), values ( i )) enddo endif contains subroutine printme ( ii , jj ) integer , intent ( in ) :: ii integer , intent ( in ) :: jj integer :: ivalue , j , k do ivalue = ii , jj ! for values from ii to jj print factors call prime_factors ( ivalue , nprm , iprm , iexp , verbose ) ! get the factors if (. not . verbose ) then ! if not printed yet print the values write ( * , '(i0,\": \",*(i0:,1x))' ) ivalue ,( ( iprm ( k ), j = 1 , iexp ( k )) , k = 1 , nprm ) ! \"VALUE: FACTOR(1) FACTOR(2) FACTOR(3) ...\" endif enddo end subroutine printme end program find_prime_factors subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       factors(1f) - [NUMBERS] display prime factors of numbers                                                                 ' ,& '       (LICENSE:PD)                                                                                                             ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       factors [NUMBER]...                                                                                                      ' ,& '       factors -start N -end M                                                                                                  ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Print the prime factors of each specified integer NUMBER. If none are                                                        ' ,& '   specified on the command line, read them from standard input.                                                                ' ,& '                                                                                                                                ' ,& '   Typically, the numbers must be positive integers where                                                                       ' ,& '                                                                                                                                ' ,& '      2 <= NUMBER <= (2**31)-1 or 2147483647.                                                                                   ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '       -start N   if specified factor a range of numbers starting with this                                                     ' ,& '                  value. If -end is specified defaults to 2.                                                                    ' ,& '       -end M     if specified factor a range of numbers ending with this                                                       ' ,& '                  value. If -start is specified defaults to huge(0).                                                            ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --verbose  verbose output                                                                                                ' ,& 'EXAMPLE                                                                                                                         ' ,& ' Sample Usage:                                                                                                                  ' ,& '                                                                                                                                ' ,& '  factors 512                                                                                                                   ' ,& '  512: 2 2 2 2 2 2 2 2 2                                                                                                        ' ,& '                                                                                                                                ' ,& '  factors 512 -verbose                                                                                                          ' ,& '  512 factors as (2**9)                                                                                                         ' ,& '                                                                                                                                ' ,& '  factors 202023 2147483647 -verbose                                                                                            ' ,& '  202023 factors as (3**2)*22447                                                                                                ' ,& '  2147483647 IS A PRIME NUMBER                                                                                                  ' ,& '                                                                                                                                ' ,& '  factors -start 2 -end 12 -verbose                                                                                             ' ,& '  2 IS A PRIME NUMBER                                                                                                           ' ,& '  3 IS A PRIME NUMBER                                                                                                           ' ,& '  4 factors as (2**2)                                                                                                           ' ,& '  5 IS A PRIME NUMBER                                                                                                           ' ,& '  6 factors as 2*3                                                                                                              ' ,& '  7 IS A PRIME NUMBER                                                                                                           ' ,& '  8 factors as (2**3)                                                                                                           ' ,& '  9 factors as (3**2)                                                                                                           ' ,& '  10 factors as 2*5                                                                                                             ' ,& '  11 IS A PRIME NUMBER                                                                                                          ' ,& '  12 factors as (2**2)*3                                                                                                        ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!        factors(1f) - [NUMBERS] display prime factors of numbers !!        (LICENSE:PD) !! !!##SYNOPSIS !! !!        factors [NUMBER]... !!        factors -start N -end M !! !!##DESCRIPTION !!    Print the prime factors of each specified integer NUMBER. If none are !!    specified on the command line, read them from standard input. !! !!    Typically, the numbers must be positive integers where !! !!       2 <= NUMBER <= (2**31)-1 or 2147483647. !! !!##OPTIONS !!        -start N   if specified factor a range of numbers starting with this !!                   value. If -end is specified defaults to 2. !!        -end M     if specified factor a range of numbers ending with this !!                   value. If -start is specified defaults to huge(0). !!        --help     display this help and exit !!        --version  output version information and exit !!        --verbose  verbose output !!##EXAMPLE !! !!  Sample Usage: !! !!   factors 512 !!   512: 2 2 2 2 2 2 2 2 2 !! !!   factors 512 -verbose !!   512 factors as (2**9) !! !!   factors 202023 2147483647 -verbose !!   202023 factors as (3**2)*22447 !!   2147483647 IS A PRIME NUMBER !! !!   factors -start 2 -end 12 -verbose !!   2 IS A PRIME NUMBER !!   3 IS A PRIME NUMBER !!   4 factors as (2**2) !!   5 IS A PRIME NUMBER !!   6 factors as 2*3 !!   7 IS A PRIME NUMBER !!   8 factors as (2**3) !!   9 factors as (3**2) !!   10 factors as 2*5 !!   11 IS A PRIME NUMBER !!   12 factors as (2**2)*3 !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        factors(1f)>' ,& '@(#)DESCRIPTION:    Determine prime factors of numbers>' ,& '@(#)VERSION:        1.1, 20161007>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain>' ,& '@(#)COMPILED:       2022-01-03 20:17:45 UTC-300>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"sourcefile/factors.f90.html"},{"title":"lcm.f90 – easy","text":"Contents Programs find_lcm Subroutines help_usage help_version Source Code lcm.f90 Source Code program find_lcm Use M_factor , only : lcm => least_common_multiple Use M_strings , only : s2vs use M_kracken , only : kracken , igets , lget ! command line parsing implicit none integer :: ios integer , allocatable :: values (:) integer :: answer character ( len = 4096 ) :: line logical :: verbose = . false . call kracken ( 'lcm' , '--help F --version F -verbose F ' ) ! crack command line options call help_usage ( lget ( 'lcm_help' )) ! if help text requested display it and quit call help_version ( lget ( 'lcm_version' )) ! if version information requested display it and quit verbose = lget ( 'lcm_verbose' ) values = igets ( 'lcm_oo' ) ! get numbers from command line if ( size ( values ). eq . 0 ) then ! if did not print a range and no number specified prompt for values INFINITE : do read ( * , '(a)' , iostat = ios ) line ! read line of numbers if ( is_iostat_end ( ios )) then exit elseif ( ios . ne . 0 ) then cycle endif values = int ( s2vs ( line )) ! convert text line to array of numbers if ( size ( values ). ne . 0 ) then answer = lcm ( values ) ! function can return error messages, so do not call from WRITE(3f) if ( verbose ) then write ( * , '(i0,\"=lcm([\",*(i0:,\",\"))' , advance = 'no' ) answer , values write ( * , '(\"])\")' ) else write ( * , '(i0)' ) answer endif endif enddo INFINITE else answer = lcm ( values ) ! function can return error messages, so do not call from WRITE(3f) if ( verbose ) then write ( * , '(i0,\"=lcm([\",*(i0:,\",\"))' , advance = 'no' ) answer , values write ( * , '(\"])\")' ) else write ( * , '(i0)' ) answer endif endif end program find_lcm subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       lcm(1f) - [NUMBERS] display least common multiple of a list of whole numbers                                             ' ,& '       (LICENSE:PD)                                                                                                             ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       lcm [NUMBERS]...                                                                                                         ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Print the LCM (Least Common Multiple) of a list of integer whole                                                             ' ,& '   NUMBERS. If none are specified on the command line, read them from                                                           ' ,& '   standard input, one list per line.                                                                                           ' ,& '                                                                                                                                ' ,& '   Typically, the numbers must be positive integers where                                                                       ' ,& '                                                                                                                                ' ,& '      2 <= NUMBER <= (2**31)-1 or 2147483647.                                                                                   ' ,& '                                                                                                                                ' ,& '   but if the result would be larger than (2**31)-1 an error is returned                                                        ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '       NUMBERS    list of numbers whose least common multiple is to be                                                          ' ,& '                  determined                                                                                                    ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --verbose  produce verbose answer instead of simple integer result                                                       ' ,& 'EXAMPLE                                                                                                                         ' ,& ' Sample Usage:                                                                                                                  ' ,& '                                                                                                                                ' ,& '  >lcm 10 34 82                                                                                                                 ' ,& '  >6970                                                                                                                         ' ,& '                                                                                                                                ' ,& '  >lcm 10 34 82 -verbose                                                                                                        ' ,& '  >6970=lcm([10,34,82])                                                                                                         ' ,& '                                                                                                                                ' ,& '  >lcm 202023 2147483647                                                                                                        ' ,& '  >STOP 1                                                                                                                       ' ,& '  >*lcm* result larger than a standard integer = 433841088817881                                                                ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '                                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!        lcm(1f) - [NUMBERS] display least common multiple of a list of whole numbers !!        (LICENSE:PD) !! !!##SYNOPSIS !! !!        lcm [NUMBERS]... !! !!##DESCRIPTION !!    Print the LCM (Least Common Multiple) of a list of integer whole !!    NUMBERS. If none are specified on the command line, read them from !!    standard input, one list per line. !! !!    Typically, the numbers must be positive integers where !! !!       2 <= NUMBER <= (2**31)-1 or 2147483647. !! !!    but if the result would be larger than (2**31)-1 an error is returned !! !!##OPTIONS !!        NUMBERS    list of numbers whose least common multiple is to be !!                   determined !!        --help     display this help and exit !!        --version  output version information and exit !!        --verbose  produce verbose answer instead of simple integer result !!##EXAMPLE !! !!  Sample Usage: !! !!   >lcm 10 34 82 !!   >6970 !! !!   >lcm 10 34 82 -verbose !!   >6970=lcm([10,34,82]) !! !!   >lcm 202023 2147483647 !!   >STOP 1 !!   >*lcm* result larger than a standard integer = 433841088817881 !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        lcm(1f)>' ,& '@(#)DESCRIPTION:    Determine least common multiple of a list of integers>' ,& '@(#)!VERSION:       1.0, 20170317>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)UUID:           8f39b1e5-592f-4a22-946f-b8da2aa49633>' ,& '@(#)COMPILED:       2022-01-03 20:17:45 UTC-300>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"sourcefile/lcm.f90.html"},{"title":"gcd.f90 – easy","text":"Contents Programs find_gcd Subroutines help_usage help_version Source Code gcd.f90 Source Code program find_gcd Use M_factor , only : gcd => greatest_common_divisor Use M_strings , only : s2vs use M_kracken , only : kracken , igets , lget ! command line parsing implicit none integer :: ios , ios_count = 0 integer , allocatable :: values (:) integer :: answer character ( len = 4096 ) :: line logical :: verbose = . false . !----------------------------------------------------------------------------------------------------------------------------------- call kracken ( 'gcd' , '--help F --version F -verbose F ' ) ! crack command line options call help_usage ( lget ( 'gcd_help' )) ! if help text requested display it and quit call help_version ( lget ( 'gcd_version' )) ! if version information requested display it and quit verbose = lget ( 'gcd_verbose' ) ! get -verbose flag values = igets ( 'gcd_oo' ) ! get numbers from command line !----------------------------------------------------------------------------------------------------------------------------------- if ( size ( values ). eq . 0 ) then ! if did not print a range and no number specified prompt for values INFINITE : do read ( * , '(a)' , iostat = ios ) line ! read line of numbers if ( is_iostat_end ( ios )) then ! if got EOF(end of file) exit loop exit INFINITE elseif ( ios . ne . 0 ) then ! if I/O error reading line read another (could loop on system errors) ios_count = ios_count + 1 if ( ios_count . gt . 1000 ) exit INFINITE ! check to avoid infinite loop if stuck on system I/O error not an EOF cycle INFINITE ! get a new line, had error reading last one endif values = int ( s2vs ( line )) ! convert text line to array of numbers if ( size ( values ). ne . 0 ) then answer = gcd ( values ) ! function can return error messages, so do not call from WRITE(3f) if ( verbose ) then ! write in format \"ANSWER=gcd([VAL(1),VAL(2),VAL(3),...]) write ( * , '(i0,\"=gcd([\",*(i0:,\",\"))' , advance = 'no' ) answer , values write ( * , '(\"])\")' ) else ! just simply write integer answer write ( * , '(i0)' ) answer endif endif enddo INFINITE else answer = gcd ( values ) ! function can return error messages, so do not call from WRITE(3f) if ( verbose ) then write ( * , '(i0,\"=gcd([\",*(i0:,\",\"))' , advance = 'no' ) answer , values write ( * , '(\"])\")' ) else write ( * , '(i0)' ) answer endif endif !----------------------------------------------------------------------------------------------------------------------------------- end program find_gcd subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       gcd(1f) - [NUMBERS] display greatest common divisor of a list of whole numbers                                           ' ,& '       (LICENSE:PD)                                                                                                             ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       gcd [NUMBERS]...                                                                                                         ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Print the gcd (Greatest Common Divisor) of a list of integer whole                                                           ' ,& '   NUMBERS. If none are specified on the command line, read them from                                                           ' ,& '   standard input, one list per line.                                                                                           ' ,& '                                                                                                                                ' ,& '   Typically, the numbers must be positive integers where                                                                       ' ,& '                                                                                                                                ' ,& '      2 <= NUMBER <= (2**31)-1 or 2147483647.                                                                                   ' ,& '                                                                                                                                ' ,& '   but if the result would be larger than (2**31)-1 an error is returned                                                        ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '       NUMBERS    list of numbers whose greatest common divisor is to be                                                        ' ,& '                  determined                                                                                                    ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --verbose  produce verbose answer instead of simple integer result                                                       ' ,& 'EXAMPLE                                                                                                                         ' ,& ' Sample Usage:                                                                                                                  ' ,& '                                                                                                                                ' ,& '  gcd 10 34 82                                                                                                                  ' ,& '  2                                                                                                                             ' ,& '                                                                                                                                ' ,& '  gcd 10 34 82 -verbose                                                                                                         ' ,& '  2=gcd([10,34,82])                                                                                                             ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '                                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!        gcd(1f) - [NUMBERS] display greatest common divisor of a list of whole numbers !!        (LICENSE:PD) !! !!##SYNOPSIS !! !!        gcd [NUMBERS]... !! !!##DESCRIPTION !!    Print the gcd (Greatest Common Divisor) of a list of integer whole !!    NUMBERS. If none are specified on the command line, read them from !!    standard input, one list per line. !! !!    Typically, the numbers must be positive integers where !! !!       2 <= NUMBER <= (2**31)-1 or 2147483647. !! !!    but if the result would be larger than (2**31)-1 an error is returned !! !!##OPTIONS !!        NUMBERS    list of numbers whose greatest common divisor is to be !!                   determined !!        --help     display this help and exit !!        --version  output version information and exit !!        --verbose  produce verbose answer instead of simple integer result !!##EXAMPLE !! !!  Sample Usage: !! !!   gcd 10 34 82 !!   2 !! !!   gcd 10 34 82 -verbose !!   2=gcd([10,34,82]) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        gcd(1f)>' ,& '@(#)DESCRIPTION:    Determine greatest common divisor of a list of integers>' ,& '@(#)!VERSION:       1.0, 20170317>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)UUID:           8f39b1e5-592f-4a22-946f-b8da2aa49633>' ,& '@(#)COMPILED:       2022-01-03 20:17:45 UTC-300>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"sourcefile/gcd.f90.html"},{"title":"demo_i_is_prime.f90 – easy","text":"Contents Programs demo_i_is_prime Source Code demo_i_is_prime.f90 Source Code program demo_i_is_prime use M_factor , only : i_is_prime implicit none integer :: i integer :: icount = 0 integer :: isum = 0 integer , parameter :: n = 10000 do i = 2 , n if ( i_is_prime ( i )) then icount = icount + 1 isum = isum + i write ( * , * ) icount , i endif enddo write ( * , * ) 'number of primes between 2 and ' , n , ' is ' , icount write ( * , * ) 'sum of primes between 2 and ' , n , ' is ' , isum write ( * , * ) i_is_prime ([ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ]) write ( * , * ) all (. not . i_is_prime ([ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ])) write ( * , * ) any (. not . i_is_prime ([ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ])) end program demo_i_is_prime","tags":"","loc":"sourcefile/demo_i_is_prime.f90.html"},{"title":"demo_greatest_common_divisor.f90 – easy","text":"Contents Programs demo_greatest_common_divisor Source Code demo_greatest_common_divisor.f90 Source Code program demo_greatest_common_divisor use M_factor , only : gcd => greatest_common_divisor implicit none integer , allocatable :: matrix (:,:) ! SCALAR: call writeit ( 26 , 130 , 26 ) call writeit ( 91 , 390 , 13 ) call writeit ( - 91 , 390 , 13 ) call writeit ( 91 , - 390 , 13 ) call writeit ( - 41 , - 43 , 1 ) call writeit ( - 20 , - 10 , 10 ) call writeit ( 20 , 10 , 10 ) ! VECTOR: call writeit_v ([ 26 , 130 , 91 , 390 ], 13 ) call writeit_v ([ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ], 1 ) call writeit_v ([ - 20 , - 10 , 0 ], 10 ) call writeit_v ([ 20 , 10 , 0 ], 10 ) call writeit_v ([ 26 , 130 ], 26 ) call writeit_v ([ 91 , 390 ], 13 ) call writeit_v ([ - 91 , 390 ], 13 ) call writeit_v ([ 91 , - 390 ], 13 ) call writeit_v ([ - 41 , - 43 ], 1 ) call writeit_v ([ - 20 , - 10 ], 10 ) call writeit_v ([ 20 , 10 ], 10 ) ! MATRIX: matrix = reshape ([ 11 , 22 , 33 , 44 , 55 , 66 ],[ 2 , 3 ]) call write_matrix ( matrix , 11 ) matrix = reshape ([ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ],[ 13 , 1 ]) call write_matrix ( matrix , 1 ) matrix = reshape ([ 40 , 80 , 120 , 160 ],[ 2 , 2 ]) call write_matrix ( matrix , 40 ) contains subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer write ( * , '(\"gcd([\",i0,\",\",i0,\"]) produces \",i0,\" which is \",l1)' ) & & ii , jj , gcd ( ii , jj ), gcd ( ii , jj ). eq . answer end subroutine writeit subroutine writeit_v ( vector , answer ) integer , intent ( in ) :: vector (:) integer , intent ( in ) :: answer write ( * , '(\"gcd([\",*(i0:,\",\"))' , advance = 'no' ) vector write ( * , '(\"]) produces \",i0,\" which is \",l1)' ) & & gcd ( vector ), gcd ( vector ). eq . answer end subroutine writeit_v subroutine write_matrix ( matrix , answer ) integer , intent ( in ) :: matrix (:,:) integer , intent ( in ) :: answer write ( * , * ) 'MATRIX SHAPE:' , size ( matrix , dim = 1 ), size ( matrix , dim = 2 ) write ( * , '(\"gcd([\",*(i0:,\",\"))' , advance = 'no' ) matrix write ( * , '(\"]) produces \",i0,\" which is \",l1)' ) & & gcd ( matrix ), gcd ( matrix ). eq . answer end subroutine write_matrix end program demo_greatest_common_divisor","tags":"","loc":"sourcefile/demo_greatest_common_divisor.f90.html"},{"title":"demo_prime_factors.f90 – easy","text":"Contents Programs demo_prime_factors Source Code demo_prime_factors.f90 Source Code program demo_prime_factors use M_factor , only : prime_factors implicit none integer :: number integer :: iexp ( 10 ), iprm ( 10 ), nprm logical :: verbose = . true . integer :: ios do write ( * , '(a)' , advance = 'no' ) ' Enter number to be factored: ' read ( * , * , iostat = ios , end = 999 ) number if ( ios . eq . 0 ) then call prime_factors ( number , nprm , iprm , iexp , verbose ) endif enddo 999 continue end program demo_prime_factors","tags":"","loc":"sourcefile/demo_prime_factors.f90.html"},{"title":"demo_least_common_multiple.f90 – easy","text":"Contents Programs demo_lcm Source Code demo_least_common_multiple.f90 Source Code program demo_lcm use M_factor , only : lcm => least_common_multiple implicit none write ( * , * ) 'SCALAR:' call writeit ( 10 , 24 , 120 ) call writeit ( 15 , 30 , 30 ) call writeit ( - 15 , - 30 , 30 ) call writeit ( 15 , - 30 , 30 ) call writeit ( - 15 , 30 , 30 ) write ( * , * ) 'VECTOR:' call writeit_v ([ 10 , 24 ], 120 ) call writeit_v ([ 15 , 30 ], 30 ) call writeit_v ([ - 15 , - 30 ], 30 ) call writeit_v ([ 5 , - 15 , - 40 ], 120 ) call writeit_v ([ 2 , 3 , 4 , 5 ], 60 ) write ( * , * ) 'Special cases:' call writeit_v ([ 15 , 0 ], 0 ) call writeit_v ([ - 15 , 0 ], 0 ) call writeit_v ([ 0 ], 0 ) call writeit_v ([ - 10 ], 10 ) call writeit_v ([ 22 ], 22 ) call writeit_v ([ 0 , 0 ], 0 ) call writeit_v ([ 0 , 0 , 0 , 0 , 0 ], 0 ) call writeit_v ([ 0 , 0 , 0 , - 1 , 0 ], 0 ) call writeit_v ([ 0 , 0 , 0 , 33 , 0 , 3 , 11 ], 0 ) contains subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer write ( * , '(\"  For lcm(\",I0,\",\",I0,\") the value is \",I0,\" which is \",L1)' )& & ii , jj , lcm ( ii , jj ), lcm ( ii , jj ). eq . answer end subroutine writeit subroutine writeit_v ( array , answer ) integer , intent ( in ) :: array (:) integer , intent ( in ) :: answer write ( * , '(\"  For lcm([\",*(i0:,1x))' , advance = 'no' ) array write ( * , '(\"]) the value is \",i0,\" which is \",L1)' ) & & lcm ( array ), lcm ( array ). eq . answer end subroutine writeit_v end program demo_lcm","tags":"","loc":"sourcefile/demo_least_common_multiple.f90.html"},{"title":"test_suite_M_factor.f90 – easy","text":"Contents Programs test_suite_M_factor Subroutines test_least_common_multiple test_greatest_common_divisor test_i_is_prime test_prime_factors Source Code test_suite_M_factor.f90 Source Code !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! program test_suite_M_factor use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use :: M_verify , only : unit_check , unit_check_good , unit_check_bad , unit_check_done , unit_check_start , unit_check_level use :: M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level use M_verify , only : unit_check_stop use :: M_factor implicit none integer , parameter :: HT = 9 unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call unit_check_start ( 'M_BRE' ) call test_greatest_common_divisor call test_i_is_prime call test_least_common_multiple call test_prime_factors !x!call test_gcd !x!call test_gcd_2 call unit_check_stop () end program test_suite_M_factor !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_least_common_multiple use M_verify , only : unit_check , unit_check_good , unit_check_done , unit_check_start , unit_check_level use :: M_factor implicit none call unit_check_start ( 'least_common_multiple' ) ! SCALAR: call writeit ( 10 , 24 , 120 , 'scalar:' ) call writeit ( 15 , 30 , 30 , 'scalar:' ) call writeit ( - 15 , - 30 , 30 , 'scalar:' ) call writeit ( 15 , - 30 , 30 , 'scalar:' ) call writeit ( - 15 , 30 , 30 , 'scalar:' ) ! VECTOR: call writeit_v ([ 10 , 24 ], 120 , 'vector:' ) call writeit_v ([ 15 , 30 ], 30 , 'vector:' ) call writeit_v ([ - 15 , - 30 ], 30 , 'vector:' ) call writeit_v ([ 5 , - 15 , - 40 ], 120 , 'vector:' ) call writeit_v ([ 2 , 3 , 4 , 5 ], 60 , 'vector:' ) ! Special cases: call writeit_v ([ 15 , 0 ], 0 , 'special cases:' ) call writeit_v ([ - 15 , 0 ], 0 , 'special cases:' ) call writeit_v ([ 0 ], 0 , 'special cases:' ) call writeit_v ([ - 10 ], 10 , 'special cases:' ) call writeit_v ([ 22 ], 22 , 'special cases:' ) call writeit_v ([ 0 , 0 ], 0 , 'special cases:' ) call writeit_v ([ 0 , 0 , 0 , 0 , 0 ], 0 , 'special cases:' ) call writeit_v ([ 0 , 0 , 0 , - 1 , 0 ], 0 , 'special cases:' ) call writeit_v ([ 0 , 0 , 0 , 33 , 0 , 3 , 11 ], 0 , 'special cases:' ) call unit_check_done ( 'least_common_multiple' ) contains subroutine writeit ( ii , jj , answer , message ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer character ( len =* ), intent ( in ) :: message character ( len = 1024 ) :: line write ( line , '(a,\"For least_common_multiple(\",I0,\",\",I0,\") the value is \",I0,\" which is \",L1)' )& & trim ( message ), ii , jj , least_common_multiple ( ii , jj ), least_common_multiple ( ii , jj ). eq . answer call unit_check ( 'least_common_multiple' , least_common_multiple ( ii , jj ). eq . answer , msg = line ) end subroutine writeit subroutine writeit_v ( array , answer , message ) integer , intent ( in ) :: array (:) integer , intent ( in ) :: answer character ( len =* ), intent ( in ) :: message character ( len = 1024 ) :: line integer :: i write ( line , '(a,*(i0,1x))' ) \"For LCM([\" ,[( array ( i ), i = 1 , size ( array ))] call unit_check ( 'least_common_multiple' , least_common_multiple ( array ). eq . answer , message , line , ']) the value is' , answer ) end subroutine writeit_v end subroutine test_least_common_multiple !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_greatest_common_divisor use M_verify , only : unit_check , unit_check_good , unit_check_done , unit_check_start , unit_check_level use :: M_factor implicit none integer , allocatable :: matrix (:,:) call unit_check_start ( 'greatest_common_divisor' ) ! SCALAR: call writeit ( 26 , 130 , 26 ) call writeit ( 91 , 390 , 13 ) call writeit ( - 91 , 390 , 13 ) call writeit ( 91 , - 390 , 13 ) call writeit ( - 41 , - 43 , 1 ) call writeit ( - 20 , - 10 , 10 ) call writeit ( 20 , 10 , 10 ) ! VECTOR: call writeit_v ([ 26 , 130 , 91 , 390 ], 13 ) call writeit_v ([ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ], 1 ) call writeit_v ([ - 20 , - 10 , 0 ], 10 ) call writeit_v ([ 20 , 10 , 0 ], 10 ) call writeit_v ([ 26 , 130 ], 26 ) call writeit_v ([ 91 , 390 ], 13 ) call writeit_v ([ - 91 , 390 ], 13 ) call writeit_v ([ 91 , - 390 ], 13 ) call writeit_v ([ - 41 , - 43 ], 1 ) call writeit_v ([ - 20 , - 10 ], 10 ) call writeit_v ([ 20 , 10 ], 10 ) ! MATRIX: matrix = reshape ([ 11 , 22 , 33 , 44 , 55 , 66 ],[ 2 , 3 ]) call write_matrix ( matrix , 11 ) matrix = reshape ([ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ],[ 13 , 1 ]) call write_matrix ( matrix , 1 ) matrix = reshape ([ 40 , 80 , 120 , 160 ],[ 2 , 2 ]) call write_matrix ( matrix , 40 ) call unit_check_done ( 'greatest_common_divisor' ) contains subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer character ( len = 1024 ) :: line write ( line , '(\"greatest_common_divisor([\",i0,\",\",i0,\"]) produces \",i0)' ) ii , jj , greatest_common_divisor ( ii , jj ) call unit_check ( 'greatest_common_divisor' , greatest_common_divisor ( ii , jj ). eq . answer , msg = line ) end subroutine writeit subroutine writeit_v ( vector , answer ) integer , intent ( in ) :: vector (:) integer , intent ( in ) :: answer character ( len = 1024 ) :: line1 character ( len = 1024 ) :: line2 write ( line1 , '(\"GCD([\",*(i0:,\",\"))' ) vector write ( line2 , '(\"]) produces \",i0)' ) greatest_common_divisor ( vector ) call unit_check ( 'greatest_common_divisor' , greatest_common_divisor ( vector ). eq . answer , line1 , line2 ) end subroutine writeit_v subroutine write_matrix ( matrix , answer ) integer , intent ( in ) :: matrix (:,:) integer , intent ( in ) :: answer character ( len = 1024 ) :: line1 character ( len = 1024 ) :: line2 character ( len = 1024 ) :: line3 write ( line1 , '(a,i0,1x,i0)' ) 'MATRIX SHAPE:' , size ( matrix , dim = 1 ), size ( matrix , dim = 2 ) write ( line2 , '(\"GCD([\",*(i0:,\",\"))' ) matrix write ( line3 , '(\"]) produces \",i0)' ) greatest_common_divisor ( matrix ) call unit_check ( 'greatest_common_divisor' , greatest_common_divisor ( matrix ). eq . answer , line1 , line2 , line3 ) end subroutine write_matrix end subroutine test_greatest_common_divisor !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_i_is_prime use M_verify , only : unit_check , unit_check_good , unit_check_done , unit_check_start , unit_check_level use :: M_factor implicit none integer :: i integer :: icount = 0 integer :: isum = 0 !*!integer  :: n=2**31-1 integer :: n = 10000 integer , parameter :: nn ( * ) = [ 9973 , 1127326861 , 1127326883 , 1127326897 , 1127326901 , 1127326927 , 1127326957 , & 1127326961 , 1127326969 , 1127326973 , 1127327029 ] call unit_check_start ( 'i_is_prime' ) do i = 2 , n if ( i_is_prime ( i )) then icount = icount + 1 isum = isum + i if ( unit_check_level . gt . 0 ) then write ( * , * ) 'prime ' , icount , ' is ' , i , isum endif endif enddo if ( unit_check_level . gt . 0 ) then write ( * , * ) 'number of primes from 2 to ' , n , ' is ' , icount write ( * , * ) 'sum of primes from 2 to ' , n , ' is ' , isum endif call unit_check ( 'i_is_prime' , icount . eq . 1229 , msg = 'should be 1229' ) call unit_check ( 'i_is_prime' , isum . eq . 5736396 , msg = 'should be 5736396' ) CHECKTHEM : block do i = 1 , size ( nn ) call unit_check ( 'i_is_prime' , i_is_prime ( nn ( i )), 'testing' , nn ( i ), 'which should be prime' ) enddo endblock CHECKTHEM call unit_check ( 'i_is_prime' , all (. not . i_is_prime ([ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ])), msg = 'check some values that are not prime' ) call unit_check_done ( 'i_is_prime' ) end subroutine test_i_is_prime !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_prime_factors use M_verify , only : unit_check , unit_check_good , unit_check_done , unit_check_start , unit_check_level use :: M_factor implicit none integer , allocatable :: primes (:) integer , allocatable :: exponents (:) integer :: iexp ( 10 ), iprm ( 10 ), nprm , number logical :: verbose = . true . if ( unit_check_level . gt . 0 ) then verbose = . true . else verbose = . false . endif call unit_check_start ( 'prime_factors' ) number = 2030303 primes = [ 11 , 379 , 487 ] exponents = [ 1 , 1 , 1 ] call prime_factors ( number , nprm , iprm , iexp , verbose ) call unit_check ( 'prime_factors' , all ( iprm (: nprm ). eq . primes ). and . all ( iexp (: nprm ). eq . exponents ), 'factors of ' , number ) number = 2147483646 primes = [ 2 , 3 , 7 , 11 , 31 , 151 , 331 ] exponents = [ 1 , 2 , 1 , 1 , 1 , 1 , 1 ] call prime_factors ( number , nprm , iprm , iexp , verbose ) call unit_check ( 'prime_factors' , all ( iprm (: nprm ). eq . primes ). and . all ( iexp (: nprm ). eq . exponents ), 'factors of ' , number ) number = 2147483647 primes = [ 2147483647 ] exponents = [ 1 ] call prime_factors ( number , nprm , iprm , iexp , verbose ) call unit_check ( 'prime_factors' , all ( iprm (: nprm ). eq . primes ). and . all ( iexp (: nprm ). eq . exponents ), 'factors of ' , number ) call unit_check_done ( 'prime_factors' ) end subroutine test_prime_factors !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================!","tags":"","loc":"sourcefile/test_suite_m_factor.f90.html"},{"title":"help_usage – easy","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       factors(1f) - [NUMBERS] display prime factors of numbers                                                                 ' ,& '       (LICENSE:PD)                                                                                                             ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       factors [NUMBER]...                                                                                                      ' ,& '       factors -start N -end M                                                                                                  ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Print the prime factors of each specified integer NUMBER. If none are                                                        ' ,& '   specified on the command line, read them from standard input.                                                                ' ,& '                                                                                                                                ' ,& '   Typically, the numbers must be positive integers where                                                                       ' ,& '                                                                                                                                ' ,& '      2 <= NUMBER <= (2**31)-1 or 2147483647.                                                                                   ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '       -start N   if specified factor a range of numbers starting with this                                                     ' ,& '                  value. If -end is specified defaults to 2.                                                                    ' ,& '       -end M     if specified factor a range of numbers ending with this                                                       ' ,& '                  value. If -start is specified defaults to huge(0).                                                            ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --verbose  verbose output                                                                                                ' ,& 'EXAMPLE                                                                                                                         ' ,& ' Sample Usage:                                                                                                                  ' ,& '                                                                                                                                ' ,& '  factors 512                                                                                                                   ' ,& '  512: 2 2 2 2 2 2 2 2 2                                                                                                        ' ,& '                                                                                                                                ' ,& '  factors 512 -verbose                                                                                                          ' ,& '  512 factors as (2**9)                                                                                                         ' ,& '                                                                                                                                ' ,& '  factors 202023 2147483647 -verbose                                                                                            ' ,& '  202023 factors as (3**2)*22447                                                                                                ' ,& '  2147483647 IS A PRIME NUMBER                                                                                                  ' ,& '                                                                                                                                ' ,& '  factors -start 2 -end 12 -verbose                                                                                             ' ,& '  2 IS A PRIME NUMBER                                                                                                           ' ,& '  3 IS A PRIME NUMBER                                                                                                           ' ,& '  4 factors as (2**2)                                                                                                           ' ,& '  5 IS A PRIME NUMBER                                                                                                           ' ,& '  6 factors as 2*3                                                                                                              ' ,& '  7 IS A PRIME NUMBER                                                                                                           ' ,& '  8 factors as (2**3)                                                                                                           ' ,& '  9 factors as (3**2)                                                                                                           ' ,& '  10 factors as 2*5                                                                                                             ' ,& '  11 IS A PRIME NUMBER                                                                                                          ' ,& '  12 factors as (2**2)*3                                                                                                        ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage.html"},{"title":"help_version – easy","text":"subroutine help_version(l_version) NAME factors ( 1 f ) - [ NUMBERS ] display prime factors of numbers ( LICENSE : PD ) SYNOPSIS factors [ NUMBER ] ... factors - start N - end M DESCRIPTION Print the prime factors of each specified integer NUMBER . If none are specified on the command line , read them from standard input . Typically , the numbers must be positive integers where 2 <= NUMBER <= ( 2 ** 31 ) - 1 or 2147483647 . OPTIONS - start N if specified factor a range of numbers starting with this value . If - end is specified defaults to 2 . - end M if specified factor a range of numbers ending with this value . If - start is specified defaults to huge ( 0 ) . -- help display this help and exit -- version output version information and exit -- verbose verbose output EXAMPLE Sample Usage: factors 512\n   512: 2 2 2 2 2 2 2 2 2 factors 512 -verbose\n   512 factors as (2**9) factors 202023 2147483647 -verbose\n   202023 factors as (3* 2) 22447\n   2147483647 IS A PRIME NUMBER factors -start 2 -end 12 -verbose\n   2 IS A PRIME NUMBER\n   3 IS A PRIME NUMBER\n   4 factors as (2 2)\n   5 IS A PRIME NUMBER\n   6 factors as 2*3\n   7 IS A PRIME NUMBER\n   8 factors as (2 3)\n   9 factors as (3 2)\n   10 factors as 2*5\n   11 IS A PRIME NUMBER\n   12 factors as (2 2)*3 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        factors(1f)>' ,& '@(#)DESCRIPTION:    Determine prime factors of numbers>' ,& '@(#)VERSION:        1.1, 20161007>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain>' ,& '@(#)COMPILED:       2022-01-03 20:17:45 UTC-300>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version.html"},{"title":"help_usage – easy","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       lcm(1f) - [NUMBERS] display least common multiple of a list of whole numbers                                             ' ,& '       (LICENSE:PD)                                                                                                             ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       lcm [NUMBERS]...                                                                                                         ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Print the LCM (Least Common Multiple) of a list of integer whole                                                             ' ,& '   NUMBERS. If none are specified on the command line, read them from                                                           ' ,& '   standard input, one list per line.                                                                                           ' ,& '                                                                                                                                ' ,& '   Typically, the numbers must be positive integers where                                                                       ' ,& '                                                                                                                                ' ,& '      2 <= NUMBER <= (2**31)-1 or 2147483647.                                                                                   ' ,& '                                                                                                                                ' ,& '   but if the result would be larger than (2**31)-1 an error is returned                                                        ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '       NUMBERS    list of numbers whose least common multiple is to be                                                          ' ,& '                  determined                                                                                                    ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --verbose  produce verbose answer instead of simple integer result                                                       ' ,& 'EXAMPLE                                                                                                                         ' ,& ' Sample Usage:                                                                                                                  ' ,& '                                                                                                                                ' ,& '  >lcm 10 34 82                                                                                                                 ' ,& '  >6970                                                                                                                         ' ,& '                                                                                                                                ' ,& '  >lcm 10 34 82 -verbose                                                                                                        ' ,& '  >6970=lcm([10,34,82])                                                                                                         ' ,& '                                                                                                                                ' ,& '  >lcm 202023 2147483647                                                                                                        ' ,& '  >STOP 1                                                                                                                       ' ,& '  >*lcm* result larger than a standard integer = 433841088817881                                                                ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '                                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage~2.html"},{"title":"help_version – easy","text":"subroutine help_version(l_version) NAME lcm ( 1 f ) - [ NUMBERS ] display least common multiple of a list of whole numbers ( LICENSE : PD ) SYNOPSIS lcm [ NUMBERS ] ... DESCRIPTION Print the LCM ( Least Common Multiple ) of a list of integer whole NUMBERS . If none are specified on the command line , read them from standard input , one list per line . Typically , the numbers must be positive integers where 2 <= NUMBER <= ( 2 ** 31 ) - 1 or 2147483647 . but if the result would be larger than ( 2 ** 31 ) - 1 an error is returned OPTIONS NUMBERS list of numbers whose least common multiple is to be determined -- help display this help and exit -- version output version information and exit -- verbose produce verbose answer instead of simple integer result EXAMPLE Sample Usage: lcm 10 34 82\n6970 lcm 10 34 82 -verbose\n6970=lcm([10,34,82]) lcm 202023 2147483647\nSTOP 1 lcm result larger than a standard integer = 433841088817881 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        lcm(1f)>' ,& '@(#)DESCRIPTION:    Determine least common multiple of a list of integers>' ,& '@(#)!VERSION:       1.0, 20170317>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)UUID:           8f39b1e5-592f-4a22-946f-b8da2aa49633>' ,& '@(#)COMPILED:       2022-01-03 20:17:45 UTC-300>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version~2.html"},{"title":"help_usage – easy","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       gcd(1f) - [NUMBERS] display greatest common divisor of a list of whole numbers                                           ' ,& '       (LICENSE:PD)                                                                                                             ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       gcd [NUMBERS]...                                                                                                         ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Print the gcd (Greatest Common Divisor) of a list of integer whole                                                           ' ,& '   NUMBERS. If none are specified on the command line, read them from                                                           ' ,& '   standard input, one list per line.                                                                                           ' ,& '                                                                                                                                ' ,& '   Typically, the numbers must be positive integers where                                                                       ' ,& '                                                                                                                                ' ,& '      2 <= NUMBER <= (2**31)-1 or 2147483647.                                                                                   ' ,& '                                                                                                                                ' ,& '   but if the result would be larger than (2**31)-1 an error is returned                                                        ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '       NUMBERS    list of numbers whose greatest common divisor is to be                                                        ' ,& '                  determined                                                                                                    ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --verbose  produce verbose answer instead of simple integer result                                                       ' ,& 'EXAMPLE                                                                                                                         ' ,& ' Sample Usage:                                                                                                                  ' ,& '                                                                                                                                ' ,& '  gcd 10 34 82                                                                                                                  ' ,& '  2                                                                                                                             ' ,& '                                                                                                                                ' ,& '  gcd 10 34 82 -verbose                                                                                                         ' ,& '  2=gcd([10,34,82])                                                                                                             ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '                                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage~3.html"},{"title":"help_version – easy","text":"subroutine help_version(l_version) NAME gcd ( 1 f ) - [ NUMBERS ] display greatest common divisor of a list of whole numbers ( LICENSE : PD ) SYNOPSIS gcd [ NUMBERS ] ... DESCRIPTION Print the gcd ( Greatest Common Divisor ) of a list of integer whole NUMBERS . If none are specified on the command line , read them from standard input , one list per line . Typically , the numbers must be positive integers where 2 <= NUMBER <= ( 2 ** 31 ) - 1 or 2147483647 . but if the result would be larger than ( 2 ** 31 ) - 1 an error is returned OPTIONS NUMBERS list of numbers whose greatest common divisor is to be determined -- help display this help and exit -- version output version information and exit -- verbose produce verbose answer instead of simple integer result EXAMPLE Sample Usage: gcd 10 34 82\n   2 gcd 10 34 82 -verbose\n   2=gcd([10,34,82]) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        gcd(1f)>' ,& '@(#)DESCRIPTION:    Determine greatest common divisor of a list of integers>' ,& '@(#)!VERSION:       1.0, 20170317>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)UUID:           8f39b1e5-592f-4a22-946f-b8da2aa49633>' ,& '@(#)COMPILED:       2022-01-03 20:17:45 UTC-300>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version~3.html"},{"title":"test_least_common_multiple – easy","text":"subroutine test_least_common_multiple() Uses M_verify M_factor Arguments None Contents Subroutines writeit writeit_v Source Code test_least_common_multiple Subroutines subroutine writeit(ii, jj, answer, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: answer character(len=*), intent(in) :: message subroutine writeit_v(array, answer, message) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) integer, intent(in) :: answer character(len=*), intent(in) :: message Source Code subroutine test_least_common_multiple use M_verify , only : unit_check , unit_check_good , unit_check_done , unit_check_start , unit_check_level use :: M_factor implicit none call unit_check_start ( 'least_common_multiple' ) ! SCALAR: call writeit ( 10 , 24 , 120 , 'scalar:' ) call writeit ( 15 , 30 , 30 , 'scalar:' ) call writeit ( - 15 , - 30 , 30 , 'scalar:' ) call writeit ( 15 , - 30 , 30 , 'scalar:' ) call writeit ( - 15 , 30 , 30 , 'scalar:' ) ! VECTOR: call writeit_v ([ 10 , 24 ], 120 , 'vector:' ) call writeit_v ([ 15 , 30 ], 30 , 'vector:' ) call writeit_v ([ - 15 , - 30 ], 30 , 'vector:' ) call writeit_v ([ 5 , - 15 , - 40 ], 120 , 'vector:' ) call writeit_v ([ 2 , 3 , 4 , 5 ], 60 , 'vector:' ) ! Special cases: call writeit_v ([ 15 , 0 ], 0 , 'special cases:' ) call writeit_v ([ - 15 , 0 ], 0 , 'special cases:' ) call writeit_v ([ 0 ], 0 , 'special cases:' ) call writeit_v ([ - 10 ], 10 , 'special cases:' ) call writeit_v ([ 22 ], 22 , 'special cases:' ) call writeit_v ([ 0 , 0 ], 0 , 'special cases:' ) call writeit_v ([ 0 , 0 , 0 , 0 , 0 ], 0 , 'special cases:' ) call writeit_v ([ 0 , 0 , 0 , - 1 , 0 ], 0 , 'special cases:' ) call writeit_v ([ 0 , 0 , 0 , 33 , 0 , 3 , 11 ], 0 , 'special cases:' ) call unit_check_done ( 'least_common_multiple' ) contains subroutine writeit ( ii , jj , answer , message ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer character ( len =* ), intent ( in ) :: message character ( len = 1024 ) :: line write ( line , '(a,\"For least_common_multiple(\",I0,\",\",I0,\") the value is \",I0,\" which is \",L1)' )& & trim ( message ), ii , jj , least_common_multiple ( ii , jj ), least_common_multiple ( ii , jj ). eq . answer call unit_check ( 'least_common_multiple' , least_common_multiple ( ii , jj ). eq . answer , msg = line ) end subroutine writeit subroutine writeit_v ( array , answer , message ) integer , intent ( in ) :: array (:) integer , intent ( in ) :: answer character ( len =* ), intent ( in ) :: message character ( len = 1024 ) :: line integer :: i write ( line , '(a,*(i0,1x))' ) \"For LCM([\" ,[( array ( i ), i = 1 , size ( array ))] call unit_check ( 'least_common_multiple' , least_common_multiple ( array ). eq . answer , message , line , ']) the value is' , answer ) end subroutine writeit_v end subroutine test_least_common_multiple","tags":"","loc":"proc/test_least_common_multiple.html"},{"title":"test_greatest_common_divisor – easy","text":"subroutine test_greatest_common_divisor() Uses M_verify M_factor Arguments None Contents Variables matrix Subroutines write_matrix writeit writeit_v Source Code test_greatest_common_divisor Variables Type Visibility Attributes Name Initial integer, public, allocatable :: matrix (:,:) Subroutines subroutine write_matrix(matrix, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: matrix (:,:) integer, intent(in) :: answer subroutine writeit(ii, jj, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: answer subroutine writeit_v(vector, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: vector (:) integer, intent(in) :: answer Source Code subroutine test_greatest_common_divisor use M_verify , only : unit_check , unit_check_good , unit_check_done , unit_check_start , unit_check_level use :: M_factor implicit none integer , allocatable :: matrix (:,:) call unit_check_start ( 'greatest_common_divisor' ) ! SCALAR: call writeit ( 26 , 130 , 26 ) call writeit ( 91 , 390 , 13 ) call writeit ( - 91 , 390 , 13 ) call writeit ( 91 , - 390 , 13 ) call writeit ( - 41 , - 43 , 1 ) call writeit ( - 20 , - 10 , 10 ) call writeit ( 20 , 10 , 10 ) ! VECTOR: call writeit_v ([ 26 , 130 , 91 , 390 ], 13 ) call writeit_v ([ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ], 1 ) call writeit_v ([ - 20 , - 10 , 0 ], 10 ) call writeit_v ([ 20 , 10 , 0 ], 10 ) call writeit_v ([ 26 , 130 ], 26 ) call writeit_v ([ 91 , 390 ], 13 ) call writeit_v ([ - 91 , 390 ], 13 ) call writeit_v ([ 91 , - 390 ], 13 ) call writeit_v ([ - 41 , - 43 ], 1 ) call writeit_v ([ - 20 , - 10 ], 10 ) call writeit_v ([ 20 , 10 ], 10 ) ! MATRIX: matrix = reshape ([ 11 , 22 , 33 , 44 , 55 , 66 ],[ 2 , 3 ]) call write_matrix ( matrix , 11 ) matrix = reshape ([ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ],[ 13 , 1 ]) call write_matrix ( matrix , 1 ) matrix = reshape ([ 40 , 80 , 120 , 160 ],[ 2 , 2 ]) call write_matrix ( matrix , 40 ) call unit_check_done ( 'greatest_common_divisor' ) contains subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer character ( len = 1024 ) :: line write ( line , '(\"greatest_common_divisor([\",i0,\",\",i0,\"]) produces \",i0)' ) ii , jj , greatest_common_divisor ( ii , jj ) call unit_check ( 'greatest_common_divisor' , greatest_common_divisor ( ii , jj ). eq . answer , msg = line ) end subroutine writeit subroutine writeit_v ( vector , answer ) integer , intent ( in ) :: vector (:) integer , intent ( in ) :: answer character ( len = 1024 ) :: line1 character ( len = 1024 ) :: line2 write ( line1 , '(\"GCD([\",*(i0:,\",\"))' ) vector write ( line2 , '(\"]) produces \",i0)' ) greatest_common_divisor ( vector ) call unit_check ( 'greatest_common_divisor' , greatest_common_divisor ( vector ). eq . answer , line1 , line2 ) end subroutine writeit_v subroutine write_matrix ( matrix , answer ) integer , intent ( in ) :: matrix (:,:) integer , intent ( in ) :: answer character ( len = 1024 ) :: line1 character ( len = 1024 ) :: line2 character ( len = 1024 ) :: line3 write ( line1 , '(a,i0,1x,i0)' ) 'MATRIX SHAPE:' , size ( matrix , dim = 1 ), size ( matrix , dim = 2 ) write ( line2 , '(\"GCD([\",*(i0:,\",\"))' ) matrix write ( line3 , '(\"]) produces \",i0)' ) greatest_common_divisor ( matrix ) call unit_check ( 'greatest_common_divisor' , greatest_common_divisor ( matrix ). eq . answer , line1 , line2 , line3 ) end subroutine write_matrix end subroutine test_greatest_common_divisor","tags":"","loc":"proc/test_greatest_common_divisor.html"},{"title":"test_i_is_prime – easy","text":"subroutine test_i_is_prime() Uses M_verify M_factor Arguments None Contents Variables i icount isum n nn Source Code test_i_is_prime Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: icount = 0 integer, public :: isum = 0 !integer  :: n=2**31-1 integer, public :: n = 10000 integer, public, parameter :: nn (*) = [9973, 1127326861, 1127326883, 1127326897, 1127326901, 1127326927, 1127326957, 1127326961, 1127326969, 1127326973, 1127327029] Source Code subroutine test_i_is_prime use M_verify , only : unit_check , unit_check_good , unit_check_done , unit_check_start , unit_check_level use :: M_factor implicit none integer :: i integer :: icount = 0 integer :: isum = 0 !*!integer  :: n=2**31-1 integer :: n = 10000 integer , parameter :: nn ( * ) = [ 9973 , 1127326861 , 1127326883 , 1127326897 , 1127326901 , 1127326927 , 1127326957 , & 1127326961 , 1127326969 , 1127326973 , 1127327029 ] call unit_check_start ( 'i_is_prime' ) do i = 2 , n if ( i_is_prime ( i )) then icount = icount + 1 isum = isum + i if ( unit_check_level . gt . 0 ) then write ( * , * ) 'prime ' , icount , ' is ' , i , isum endif endif enddo if ( unit_check_level . gt . 0 ) then write ( * , * ) 'number of primes from 2 to ' , n , ' is ' , icount write ( * , * ) 'sum of primes from 2 to ' , n , ' is ' , isum endif call unit_check ( 'i_is_prime' , icount . eq . 1229 , msg = 'should be 1229' ) call unit_check ( 'i_is_prime' , isum . eq . 5736396 , msg = 'should be 5736396' ) CHECKTHEM : block do i = 1 , size ( nn ) call unit_check ( 'i_is_prime' , i_is_prime ( nn ( i )), 'testing' , nn ( i ), 'which should be prime' ) enddo endblock CHECKTHEM call unit_check ( 'i_is_prime' , all (. not . i_is_prime ([ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ])), msg = 'check some values that are not prime' ) call unit_check_done ( 'i_is_prime' ) end subroutine test_i_is_prime","tags":"","loc":"proc/test_i_is_prime.html"},{"title":"test_prime_factors – easy","text":"subroutine test_prime_factors() Uses M_verify M_factor Arguments None Contents Variables exponents iexp iprm nprm number primes verbose Source Code test_prime_factors Variables Type Visibility Attributes Name Initial integer, public, allocatable :: exponents (:) integer, public :: iexp (10) integer, public :: iprm (10) integer, public :: nprm integer, public :: number integer, public, allocatable :: primes (:) logical, public :: verbose = .true. Source Code subroutine test_prime_factors use M_verify , only : unit_check , unit_check_good , unit_check_done , unit_check_start , unit_check_level use :: M_factor implicit none integer , allocatable :: primes (:) integer , allocatable :: exponents (:) integer :: iexp ( 10 ), iprm ( 10 ), nprm , number logical :: verbose = . true . if ( unit_check_level . gt . 0 ) then verbose = . true . else verbose = . false . endif call unit_check_start ( 'prime_factors' ) number = 2030303 primes = [ 11 , 379 , 487 ] exponents = [ 1 , 1 , 1 ] call prime_factors ( number , nprm , iprm , iexp , verbose ) call unit_check ( 'prime_factors' , all ( iprm (: nprm ). eq . primes ). and . all ( iexp (: nprm ). eq . exponents ), 'factors of ' , number ) number = 2147483646 primes = [ 2 , 3 , 7 , 11 , 31 , 151 , 331 ] exponents = [ 1 , 2 , 1 , 1 , 1 , 1 , 1 ] call prime_factors ( number , nprm , iprm , iexp , verbose ) call unit_check ( 'prime_factors' , all ( iprm (: nprm ). eq . primes ). and . all ( iexp (: nprm ). eq . exponents ), 'factors of ' , number ) number = 2147483647 primes = [ 2147483647 ] exponents = [ 1 ] call prime_factors ( number , nprm , iprm , iexp , verbose ) call unit_check ( 'prime_factors' , all ( iprm (: nprm ). eq . primes ). and . all ( iexp (: nprm ). eq . exponents ), 'factors of ' , number ) call unit_check_done ( 'prime_factors' ) end subroutine test_prime_factors","tags":"","loc":"proc/test_prime_factors.html"},{"title":"gcd – easy","text":"public function gcd(m, n) result(answer) NAME greatest_common_divisor ( 3 f ) - [ M_factor ] calculate greatest common divisor of two integers or vector m ( : ), matrix m ( : , : ) or cuboid m ( : , : , : ) ( LICENSE : MIT ) SYNOPSIS The function is generic and may take either two integers or an integer\n   vector, matrix, or cuboid. integer function greatest_common_divisor(i,j)\ninteger,intent(in)::  i,j\n  or\ninteger function greatest_common_divisor(m)\ninteger,intent(in)::  m(:)\n or\ninteger,intent(in)::  m(:,:)\n or\ninteger,intent(in)::  m(:,:,:) DESCRIPTION The method used is the Euler algorithm; that for two integers … 1. Subtract the 2 nd number ( N ) as many times as pos sible from the 1 st on e ( M ) and save remainder using FORTRAN function MOD . 2. Test if remainder is equal to zero, if so GCD = N. If not replace M with N and N with remainder and proceed with step 1. 3. Repeat both step s until remainder becomes zero. EXAMPLE Sample program: program demo_greatest_common_divisor use M_factor , only : gcd => greatest_common_divisor implicit none integer , allocatable :: matrix ( :,: ) ! SCALAR : call writeit ( 26 , 130 , 26 ) call writeit ( 91 , 390 , 13 ) call writeit ( - 91 , 390 , 13 ) call writeit ( 91 , - 390 , 13 ) call writeit ( - 41 , - 43 , 1 ) call writeit ( - 20 , - 10 , 10 ) call writeit ( 20 , 10 , 10 ) ! VECTOR : call writeit_v ( [ 26 , 130 , 91 , 390 ], 13 ) call writeit_v ( [ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ], 1 ) call writeit_v ( [ - 20 , - 10 , 0 ], 10 ) call writeit_v ( [ 20 , 10 , 0 ], 10 ) call writeit_v ( [ 26 , 130 ], 26 ) call writeit_v ( [ 91 , 390 ], 13 ) call writeit_v ( [ - 91 , 390 ], 13 ) call writeit_v ( [ 91 , - 390 ], 13 ) call writeit_v ( [ - 41 , - 43 ], 1 ) call writeit_v ( [ - 20 , - 10 ], 10 ) call writeit_v ( [ 20 , 10 ], 10 ) ! MATRIX : matrix = reshape ( [ 11 , 22 , 33 , 44 , 55 , 66 ],[ 2 , 3 ] ) call write_matrix ( matrix , 11 ) matrix = reshape ( [ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ],[ 13 , 1 ] ) call write_matrix ( matrix , 1 ) matrix = reshape ( [ 40 , 80 , 120 , 160 ],[ 2 , 2 ] ) call write_matrix ( matrix , 40 ) contains subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer write ( * , ' (\"gcd([\",i0,\",\",i0,\"]) produces \",i0,\" which is \",l1) ' ) & & ii , jj , gcd ( ii , jj ) , gcd ( ii , jj ) . eq . answer end subroutine writeit subroutine writeit_v ( vector , answer ) integer , intent ( in ) :: vector ( : ) integer , intent ( in ) :: answer write ( * , ' (\"gcd([\",*(i0:,\",\")) ' , advance = ' no ' ) vector write ( * , ' (\"]) produces \",i0,\" which is \",l1) ' ) & & gcd ( vector ) , gcd ( vector ) . eq . answer end subroutine writeit_v subroutine write_matrix ( matrix , answer ) integer , intent ( in ) :: matrix ( :,: ) integer , intent ( in ) :: answer write ( * , * ) ' MATRIX SHAPE: ' , size ( matrix , dim = 1 ) , size ( matrix , dim = 2 ) write ( * , ' (\"gcd([\",*(i0:,\",\")) ' , advance = ' no ' ) matrix write ( * , ' (\"]) produces \",i0,\" which is \",l1) ' ) & & gcd ( matrix ) , gcd ( matrix ) . eq . answer end subroutine write_matrix end program demo_greatest_common_divisor Expected Output: >  SCALAR:\n> gcd([26,130]) produces 26 which is T\n> gcd([91,390]) produces 13 which is T\n> gcd([-91,390]) produces 13 which is T\n> gcd([91,-390]) produces 13 which is T\n> gcd([-41,-43]) produces 1 which is T\n> gcd([-20,-10]) produces 10 which is T\n> gcd([20,10]) produces 10 which is T\n>  VECTOR:\n> gcd([26,130,91,390]) produces 13 which is T\n> gcd([5,7,11,13,17,19,23,29,31,37,41,43,47]) produces 1 which is T\n> gcd([-20,-10,0]) produces 10 which is T\n> gcd([20,10,0]) produces 10 which is T\n> gcd([26,130]) produces 26 which is T\n> gcd([91,390]) produces 13 which is T\n> gcd([-91,390]) produces 13 which is T\n> gcd([91,-390]) produces 13 which is T\n> gcd([-41,-43]) produces 1 which is T\n> gcd([-20,-10]) produces 10 which is T\n> gcd([20,10]) produces 10 which is T\n>  MATRIX:\n>  MATRIX SHAPE:           2           3\n> gcd([11,22,33,44,55,66]) produces 11 which is T\n>  MATRIX SHAPE:          13           1\n> gcd([5,7,11,13,17,19,23,29,31,37,41,43,47]) produces 1 which is T\n>  MATRIX SHAPE:           2           2\n> gcd([40,80,120,160]) produces 40 which is T AUTHOR John S. Urban, 2015 LICENSE MIT License FUNCTION:    gcd(M,N)\n DATE:        30-Aug-2015 VERSION:     V1.0.0 MODIFIED BY: John S. Urban\n PURPOSE:     Computes the Greatest Common Divisor of two integers.\n              If M=N=0 then the GCD is defined to be zero.\n              IE. GCD is a factor of M and N and GCD is the largest such factor.\n REFERENCES:  Euler algorithm (slow)\n UUID:        UUID=de642070-4ecd-414b-895c-578ea7547948 Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer Contents Variables ifirst irest Source Code gcd Variables Type Visibility Attributes Name Initial integer, public :: ifirst integer, public :: irest Source Code function gcd ( m , n ) result ( answer ) implicit none ! ident_5=\"@(#)M_factor::gcd(3fp): compute greatest common divisor of two integers\" integer , intent ( in ) :: m , n integer :: answer !----------------------------------------------------------------------------------------------------------------------------------- integer :: irest intrinsic :: mod , iabs integer :: ifirst !----------------------------------------------------------------------------------------------------------------------------------- ifirst = iabs ( m ) answer = iabs ( n ) if ( answer . eq . 0 ) then answer = ifirst else do irest = mod ( ifirst , answer ) if ( irest == 0 ) exit ifirst = answer answer = irest enddo answer = iabs ( answer ) endif end function gcd","tags":"","loc":"proc/gcd.html"},{"title":"gcd_2 – easy","text":"public function gcd_2(m, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer Contents Variables answer ifirst itemp Source Code gcd_2 Variables Type Visibility Attributes Name Initial integer, public :: answer integer, public :: ifirst integer, public :: itemp Source Code integer function gcd_2 ( m , n ) implicit none integer , intent ( in ) :: m , n integer :: answer , ifirst , itemp answer = m ifirst = n do if ( ifirst . eq . 0 ) exit itemp = answer answer = ifirst ifirst = mod ( itemp , ifirst ) enddo gcd_2 = iabs ( answer ) end function gcd_2","tags":"","loc":"proc/gcd_2.html"},{"title":"i_is_prime – easy","text":"public pure elemental function i_is_prime(n) NAME i_is_prime ( 3 f ) - [ M_factor ] Determine if a number is prime using Sieve of Erasthosthenes ( LICENSE : ??? ) SYNOPSIS function i_is_prime ( n ) integer , intent ( in ) :: n DESCRIPTION A simple, unoptimized sieve of Erasthosthenes is used to check whether\nN can be divided by any integer between 2 and SQRT(N). VERSION 29 November 1998 AUTHOR John Burkardt PARAMETERS n       Input, integer N, the integer to be tested. RETURNS Output logical I_IS_PRIME ( 3 f ) is TRUE if N is prime , and FALSE otherwise . Note that negative numbers and 0 are not considered prime . EXAMPLE sample program program demo_i_is_prime use M_factor , only : i_is_prime implicit none integer :: i integer :: icount = 0 integer :: isum = 0 integer , parameter :: n = 10000 do i = 2 , n if ( i_is_prime ( i )) then icount = icount + 1 isum = isum + i write ( * , * ) icount , i endif enddo write ( * , * ) ' number of primes between 2 and ' , n , ' is ' , icount write ( * , * ) ' sum of primes between 2 and ' , n , ' is ' , isum write ( * , * ) i_is_prime ( [ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ] ) write ( * , * ) all ( . not . i_is_prime ( [ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ] )) write ( * , * ) any ( . not . i_is_prime ( [ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ] )) end program demo_i_is_prime end program demo_i_is_prime\n!exit FINDPRIME\n======= compiler bug\n!endblock FINDPRIME Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value logical !FINDPRIME: block\n======= compiler bug Contents Variables i Source Code i_is_prime Variables Type Visibility Attributes Name Initial integer, public :: i Source Code pure elemental function i_is_prime ( n ) implicit none ! ident_9=\"@(#)M_factor::i_is_prime(3f): reports whether an integer is prime\" integer , intent ( in ) :: n integer :: i logical :: i_is_prime !======= compiler bug !*!FINDPRIME: block !======= compiler bug if ( n <= 0 ) then i_is_prime = . false . else if ( n <= 3 ) then i_is_prime = . true . else do i = 2 , int ( sqrt ( real ( n ))) if ( mod ( n , i ) == 0 ) then i_is_prime = . false . !======= compiler bug !*!exit FINDPRIME !======= compiler bug goto 100 endif enddo i_is_prime = . true . endif !======= compiler bug !*!endblock FINDPRIME 100 continue !======= compiler bug end function I_IS_PRIME","tags":"","loc":"proc/i_is_prime.html"},{"title":"prime_factors – easy","text":"public subroutine prime_factors(number, nprm, iprm, iexp, verbose) NAME prime_factors ( 3 f ) - [ M_factor ] decompose a number into its prime factors SYNOPSIS call prime_factors(number,nprm,iprm,iexp[,verbose])\n\n integer, intent(in)          :: number\n integer, intent(out)         :: nprm\n integer, intent(out)         :: iprm(:)\n integer, intent(out)         :: iexp(:)\n logical, intent(in),optional :: verbose DESCRIPTION 1. Upon return from PRIME_FACTORS , NUMBER = IPRM ( 1 ) ** IEXP ( 1 ) * IPRM ( 2 ) ** IEXP ( 2 ) * ... * IPRM ( NPRM ) ** IEXP ( NPRM ) 2. A number represented by a ( sin gle - precision ) INT EGER val ue on the VMS VAX cluster can have at most 9 distinct prime factors . On machines where the maximum int eger is larger than 2 ** 31 - 1 , IPRM and IEXP would , in general , have to be dim ensioned larger sin ce larger numbers may have more than 9 distinct prime factors . OPTIONS NUMBER INTEGER constant or variable , number to be decomposed into prime factors . NUMBER . ge . 2. For 32 - bit integers NUMBER <= 2147483647 NPRM INTEGER variable , will contain the number of distinct prime factors of the number . IPRM INTEGER array of size at least 9 , will contain the prime factors of the number . IEXP INTEGER array of size at least 9 , will contain the exponents of the corresponding prime factors . verbose optional LOGICAL constant or variable , controls printing of results . o false - Results are not printed . o true - Results are printed . EXAMPLE Sample program: program demo_prime_factors use M_factor , only : prime_factors implicit none integer :: number integer :: iexp ( 10 ) , iprm ( 10 ) , nprm logical :: verbose = . true . integer :: ios do write ( * , ' (a) ' , advance = ' no ' ) ' Enter number to be factored: ' read ( * , * , iostat = ios , end = 999 ) number if ( ios . eq . 0 ) then call prime_factors ( number , nprm , iprm , iexp , verbose ) endif enddo 999 continue end program demo_prime_factors PEDIGREE o Coded at Madison Academic Computing Center,\n  University of Wisconsin, Madison\no FORTRAN 77 Version 1988.09\no Code converted using TO_F90 by Alan Miller, 2000-07-14T11:42:45\no Fortran 2003 version 20160918 by John S. Urban ! write ( ,’( (“(“,i0,”* “,i0,”)”:,” ”))’) (iprm(ii),iexp(ii),ii=1,nprm) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number integer, intent(out) :: nprm integer, intent(out) :: iprm (:) integer, intent(out) :: iexp (:) logical, intent(in), optional :: verbose Contents Variables base div ii indx j n offset olddiv quo rem verbose_local Source Code prime_factors Variables Type Visibility Attributes Name Initial integer, public, parameter :: base (52) = (/211, 209, 199, 197, 193, 191, 187, 181, 179, 173, 169, 167, 163, 157, 151, 149, 143, 139, 137, 131, 127, 121, 113, 109, 107, 103, 101, 97, 89, 83, 79, 73, 71, 67, 61, 59, 53, 47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2/) integer, public :: div integer, public :: ii integer, public :: indx integer, public :: j integer, public :: n integer, public :: offset integer, public :: olddiv integer, public :: quo integer, public :: rem logical, public :: verbose_local Source Code subroutine prime_factors ( number , nprm , iprm , iexp , verbose ) implicit none ! ident_10=\"@(#)M_factor::prime_factors(3f):decompose a number into its prime factors\" integer , intent ( in ) :: number ! number to factor integer , intent ( out ) :: nprm ! number of distinct prime factors integer , intent ( out ) :: iprm (:) ! distinct prime factors found, assumed dimensioned to at least 9 integer , intent ( out ) :: iexp (:) ! exponents of the corresponding prime factors in IPRM logical , intent ( in ), optional :: verbose ! .false. no printing; .true. print results !----------------------------------------------------------------------------------------------------------------------------------- !--------LOCAL VARIABLES integer :: div , indx , ii , j , n , offset , olddiv , quo , rem !---------data to obtain trial divisors 2, 3, 5, 7 and all higher numbers not divisible by 2, 3, 5, 7. integer , parameter :: base ( 52 ) = ( / & 211 , 209 , 199 , 197 , 193 , 191 , 187 , 181 , 179 , 173 , 169 , 167 , 163 , & 157 , 151 , 149 , 143 , 139 , 137 , 131 , 127 , 121 , 113 , 109 , 107 , 103 , & 101 , 97 , 89 , 83 , 79 , 73 , 71 , 67 , 61 , 59 , 53 , 47 , 43 , & 41 , 37 , 31 , 29 , 23 , 19 , 17 , 13 , 11 , 7 , 5 , 3 , 2 / ) !--------FORMAT TEMPLATE logical :: verbose_local !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( verbose )) then verbose_local = verbose else verbose_local = . false . endif !--------CHECK NUMBER.  MUST BE .GE. 2 if ( number < 2 ) then !--------ERROR, ISSUE MESSAGE AND TAKE ERROR EXIT. write ( * , \"(' *** ERROR IN PRIME_FACTORS, NUMBER =', i12, ', NUMBER MUST BE >= 2')\" ) number nprm = 0 return endif !--------INITIALIZATIONS. j = 0 n = number olddiv = 0 offset = 0 indx = 53 !--------GET NEXT TRIAL DIVISOR. do indx = indx - 1 if ( indx <= 0 ) then indx = 48 offset = offset + 210 endif div = offset + base ( indx ) !--------TEST TRIAL DIVISOR. do quo = n / div rem = n - quo * div if ( rem /= 0 ) exit !--------FACTOR FOUND, ZERO REMAINDER. n = quo if ( div <= olddiv ) then !--------MULTIPLE FACTOR. iexp ( j ) = iexp ( j ) + 1 cycle endif !--------NEW FACTOR. j = j + 1 iprm ( j ) = div iexp ( j ) = 1 olddiv = div enddo !--------NOT A FACTOR, POSITIVE REMAINDER.  CHECK DIVISOR SIZE. if ( div >= quo ) exit enddo !--------FINISHED, WHAT ISN'T FACTORED IS A PRIME (OR 1). if ( n > 1 ) then j = j + 1 iexp ( j ) = 1 iprm ( j ) = n endif nprm = j if ( verbose_local ) then !--------PRINT RESULTS IF REQUESTED. if ( nprm /= 1 . or . iexp ( 1 ) /= 1 ) then !--------NUMBER IS COMPOSITE write ( * , \"( t3, i0, ' factors as ')\" , advance = 'no' ) number !*! write (*,'(*(\"(\",i0,\"**\",i0,\")\":,\"*\"))') (iprm(ii),iexp(ii),ii=1,nprm) do ii = 1 , nprm if ( iexp ( ii ). eq . 1 ) then write ( * , '(i0)' , advance = 'no' ) iprm ( ii ) else write ( * , '(\"(\",i0,\"**\",i0,\")\")' , advance = 'no' ) iprm ( ii ), iexp ( ii ) endif if ( ii . eq . nprm ) then write ( * , * ) else write ( * , '(\"*\")' , advance = 'no' ) endif enddo else write ( * , \"( t3, i0, ' IS A PRIME NUMBER' )\" ) number !--------NUMBER IS PRIME endif endif end subroutine prime_factors","tags":"","loc":"proc/prime_factors.html"},{"title":"greatest_common_divisor – easy","text":"public interface greatest_common_divisor Contents Module Procedures gcd gcd_vector gcd_matrix gcd_cuboid Module Procedures public function gcd (m, n) result(answer) The function is generic and may take either two integers or an integer\n   vector, matrix, or cuboid. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer private function gcd_vector(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:) Return Value integer private function gcd_matrix(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:,:) Return Value integer private function gcd_cuboid(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:,:,:) Return Value integer","tags":"","loc":"interface/greatest_common_divisor.html"},{"title":"least_common_multiple – easy","text":"public interface least_common_multiple Contents Module Procedures lcm lcm_vector lcm_matrix lcm_cuboid Module Procedures private function lcm(i, j) Sample Program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer private function lcm_vector(m) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:) Return Value integer private function lcm_matrix(m) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:,:) Return Value integer private function lcm_cuboid(m) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:,:,:) Return Value integer","tags":"","loc":"interface/least_common_multiple.html"},{"title":"isprime – easy","text":"function isprime(number) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Return Value logical Contents Variables i Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/isprime.html"},{"title":"printme – easy","text":"subroutine printme(ii, jj) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii integer, intent(in) :: jj Contents Variables ivalue j k Source Code printme Variables Type Visibility Attributes Name Initial integer, public :: ivalue integer, public :: j integer, public :: k Source Code subroutine printme ( ii , jj ) integer , intent ( in ) :: ii integer , intent ( in ) :: jj integer :: ivalue , j , k do ivalue = ii , jj ! for values from ii to jj print factors call prime_factors ( ivalue , nprm , iprm , iexp , verbose ) ! get the factors if (. not . verbose ) then ! if not printed yet print the values write ( * , '(i0,\": \",*(i0:,1x))' ) ivalue ,( ( iprm ( k ), j = 1 , iexp ( k )) , k = 1 , nprm ) ! \"VALUE: FACTOR(1) FACTOR(2) FACTOR(3) ...\" endif enddo end subroutine printme","tags":"","loc":"proc/printme.html"},{"title":"write_matrix – easy","text":"subroutine write_matrix(matrix, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: matrix (:,:) integer, intent(in) :: answer Contents Source Code write_matrix Source Code subroutine write_matrix ( matrix , answer ) integer , intent ( in ) :: matrix (:,:) integer , intent ( in ) :: answer write ( * , * ) 'MATRIX SHAPE:' , size ( matrix , dim = 1 ), size ( matrix , dim = 2 ) write ( * , '(\"gcd([\",*(i0:,\",\"))' , advance = 'no' ) matrix write ( * , '(\"]) produces \",i0,\" which is \",l1)' ) & & gcd ( matrix ), gcd ( matrix ). eq . answer end subroutine write_matrix","tags":"","loc":"proc/write_matrix.html"},{"title":"writeit – easy","text":"subroutine writeit(ii, jj, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: answer Contents Source Code writeit Source Code subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer write ( * , '(\"gcd([\",i0,\",\",i0,\"]) produces \",i0,\" which is \",l1)' ) & & ii , jj , gcd ( ii , jj ), gcd ( ii , jj ). eq . answer end subroutine writeit","tags":"","loc":"proc/writeit.html"},{"title":"writeit_v – easy","text":"subroutine writeit_v(vector, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: vector (:) integer, intent(in) :: answer Contents Source Code writeit_v Source Code subroutine writeit_v ( vector , answer ) integer , intent ( in ) :: vector (:) integer , intent ( in ) :: answer write ( * , '(\"gcd([\",*(i0:,\",\"))' , advance = 'no' ) vector write ( * , '(\"]) produces \",i0,\" which is \",l1)' ) & & gcd ( vector ), gcd ( vector ). eq . answer end subroutine writeit_v","tags":"","loc":"proc/writeit_v.html"},{"title":"writeit – easy","text":"subroutine writeit(ii, jj, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: answer Contents Source Code writeit Source Code subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer write ( * , '(\"  For lcm(\",I0,\",\",I0,\") the value is \",I0,\" which is \",L1)' )& & ii , jj , lcm ( ii , jj ), lcm ( ii , jj ). eq . answer end subroutine writeit","tags":"","loc":"proc/writeit~2.html"},{"title":"writeit_v – easy","text":"subroutine writeit_v(array, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) integer, intent(in) :: answer Contents Source Code writeit_v Source Code subroutine writeit_v ( array , answer ) integer , intent ( in ) :: array (:) integer , intent ( in ) :: answer write ( * , '(\"  For lcm([\",*(i0:,1x))' , advance = 'no' ) array write ( * , '(\"]) the value is \",i0,\" which is \",L1)' ) & & lcm ( array ), lcm ( array ). eq . answer end subroutine writeit_v","tags":"","loc":"proc/writeit_v~2.html"},{"title":"M_factor – easy","text":"NAME M_factor ( 3 fm ) - [ M_factor :: INTRO ] module for least common multiple , greatest common divisor , and prime factors SYNOPSIS least_common_multiple least common multiple of two integers ( i , j ) or integer array m ( : | :,: | :,:,: ) greatest_common_divisor greatest common divisor of two integers ( i , j ) or integer array m ( : | :,: | :,:,: ) prime_factors prime factors of a number i_is_prime determine if an integer is a prime DESCRIPTION This module is a collection of procedures that perform common functions found in arithmetic and number theory such as Least Common Multiples , Greatest Common Divisors , and Prime Factors of INTEGER variables . The INTEGER values are typically limited to values up to the magnitude ( 2 ** 31 ) - 1 = 2147483647. PRIMES Date 10 / 06 / 97 at 12 : 47 : 29 From Doctor Rob Subject Re : The number 1 and zero One is neither a prime nor a composite number . A prime number is one with exactly two positive divisors , itself and one . One has only one positive divisor . It cannot be written as a product of two factors , neither of which is itself , so one is also not composite . It falls in a class of numbers called units . These are the numbers whose reciprocals are also whole numbers . Zero is not a prime or a composite number either . Zero has an infinite number of divisors ( any nonzero whole number divides zero ) . It cannot be written as a product of two factors , neither of which is itself , so zero is also not composite . It falls in a class of numbers called zero - divisors . These are numbers such that , when multiplied by some nonzero number , the product is zero . The most important fact of multiplication of integers is called the Fundamental Theorem of Arithmetic . It says that every whole number greater than one can be written * uniquely * ( except for their order ) as the product of prime numbers . This is so important that we tailor our idea of what a prime number is to make it true . If 1 were a prime number , this would be false , since , for example , 7 = 1 * 7 = 1 * 1 * 7 = 1 * 1 * 1 * 7 = ..., and the uniqueness would fail . EXAMPLES The individual man ( 1 ) pages for each procedure contain examples and a full description of the procedure parameters . Contents Interfaces greatest_common_divisor least_common_multiple Functions gcd gcd_2 i_is_prime Subroutines prime_factors Interfaces public interface greatest_common_divisor public function gcd (m, n) result(answer) The function is generic and may take either two integers or an integer\n   vector, matrix, or cuboid. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer private function gcd_vector(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:) Return Value integer private function gcd_matrix(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:,:) Return Value integer private function gcd_cuboid(m) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:,:,:) Return Value integer public interface least_common_multiple private function lcm(i, j) Sample Program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j Return Value integer private function lcm_vector(m) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:) Return Value integer private function lcm_matrix(m) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:,:) Return Value integer private function lcm_cuboid(m) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m (:,:,:) Return Value integer Functions public function gcd (m, n) result(answer) The function is generic and may take either two integers or an integer\n   vector, matrix, or cuboid. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer public function gcd_2 (m, n) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer public pure elemental function i_is_prime (n) sample program Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value logical !FINDPRIME: block\n======= compiler bug Subroutines public subroutine prime_factors (number, nprm, iprm, iexp, verbose) Sample program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: number integer, intent(out) :: nprm integer, intent(out) :: iprm (:) integer, intent(out) :: iexp (:) logical, intent(in), optional :: verbose","tags":"","loc":"module/m_factor.html"},{"title":"primes – easy","text":"Uses M_factor Contents Variables i icount n Source Code primes Variables Type Attributes Name Initial integer :: i integer :: icount = 0 integer, parameter :: n = huge(0) Source Code program primes !(LICENSE:MIT) use M_factor , only : i_is_prime implicit none integer :: i integer :: icount = 0 integer , parameter :: n = huge ( 0 ) do i = 2 , n if ( i_is_prime ( i )) then icount = icount + 1 write ( * , * ) icount , i endif enddo end program primes","tags":"","loc":"program/primes.html"},{"title":"ulam – easy","text":"Contents Variables a fmt i j n nsize spiral sstr x y Functions isprime Variables Type Attributes Name Initial integer :: a (nsize*nsize) = (/(i, i=1, nsize*nsize)/) character(len=10) :: fmt integer :: i integer :: j integer :: n integer, parameter :: nsize = 49 character(len=1) :: spiral (nsize,nsize) = \" \" character(len=2) :: sstr integer :: x integer :: y Functions function isprime (number) Arguments Type Intent Optional Attributes Name integer, intent(in) :: number Return Value logical","tags":"","loc":"program/ulam.html"},{"title":"find_prime_factors – easy","text":"Uses M_factor M_kracken write(*, ‘(a)’, advance=’no’) ‘ Enter number to be factored: ‘ Contents Variables i iend iexp ios iprm istart nprm number values verbose Subroutines printme Source Code find_prime_factors Variables Type Attributes Name Initial integer :: i integer :: iend = 0 integer :: iexp (10) integer :: ios integer :: iprm (10) integer :: istart = 0 integer :: nprm integer :: number integer, allocatable :: values (:) logical :: verbose = .true. Subroutines subroutine printme (ii, jj) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii integer, intent(in) :: jj Source Code program find_prime_factors Use M_factor , only : prime_factors ! prime number factoring routine use M_kracken , only : kracken , igets , lget , iget ! command line parsing implicit none integer :: iexp ( 10 ), iprm ( 10 ), nprm , number integer :: ios integer :: i integer , allocatable :: values (:) logical :: verbose = . true . integer :: istart = 0 integer :: iend = 0 call kracken ( 'factors' , '-help F -version F -verbose F -start 0 -end -1' ) ! crack command line options call help_usage ( lget ( 'factors_help' )) ! if help text requested display it and quit call help_version ( lget ( 'factors_version' )) ! if version information requested display it and quit values = igets ( 'factors_oo' ) ! get numbers from command line verbose = lget ( 'factors_verbose' ) ! get start and end of any range specified istart = iget ( 'factors_start' ) ! get start and end of any range specified iend = iget ( 'factors_end' ) if ( iend . gt . 0. and . istart . le . 0 ) then ! if iend specified but not istart set istart to 2 call printme ( 2 , iend ) elseif ( istart . gt . 0. and . iend . le . 0 ) then ! if istart is specified but iend is not, set iend to biggest integer call printme ( istart , huge ( 0 )) else call printme ( istart , iend ) endif if ( size ( values ). eq . 0. and .( iend - istart . le . 0 )) then ! if did not print a range and no number specified prompt for values do !!write(*, '(a)', advance='no') ' Enter number to be factored: ' read ( * , * , iostat = ios ) number if ( is_iostat_end ( ios )) then exit elseif ( ios . ne . 0 ) then cycle endif call printme ( number , number ) enddo else ! numbers are on command line do i = 1 , size ( values ) call printme ( values ( i ), values ( i )) enddo endif contains subroutine printme ( ii , jj ) integer , intent ( in ) :: ii integer , intent ( in ) :: jj integer :: ivalue , j , k do ivalue = ii , jj ! for values from ii to jj print factors call prime_factors ( ivalue , nprm , iprm , iexp , verbose ) ! get the factors if (. not . verbose ) then ! if not printed yet print the values write ( * , '(i0,\": \",*(i0:,1x))' ) ivalue ,( ( iprm ( k ), j = 1 , iexp ( k )) , k = 1 , nprm ) ! \"VALUE: FACTOR(1) FACTOR(2) FACTOR(3) ...\" endif enddo end subroutine printme end program find_prime_factors","tags":"","loc":"program/find_prime_factors.html"},{"title":"find_lcm – easy","text":"Uses M_factor M_strings M_kracken Contents Variables answer ios line values verbose Source Code find_lcm Variables Type Attributes Name Initial integer :: answer integer :: ios character(len=4096) :: line integer, allocatable :: values (:) logical :: verbose = .false. Source Code program find_lcm Use M_factor , only : lcm => least_common_multiple Use M_strings , only : s2vs use M_kracken , only : kracken , igets , lget ! command line parsing implicit none integer :: ios integer , allocatable :: values (:) integer :: answer character ( len = 4096 ) :: line logical :: verbose = . false . call kracken ( 'lcm' , '--help F --version F -verbose F ' ) ! crack command line options call help_usage ( lget ( 'lcm_help' )) ! if help text requested display it and quit call help_version ( lget ( 'lcm_version' )) ! if version information requested display it and quit verbose = lget ( 'lcm_verbose' ) values = igets ( 'lcm_oo' ) ! get numbers from command line if ( size ( values ). eq . 0 ) then ! if did not print a range and no number specified prompt for values INFINITE : do read ( * , '(a)' , iostat = ios ) line ! read line of numbers if ( is_iostat_end ( ios )) then exit elseif ( ios . ne . 0 ) then cycle endif values = int ( s2vs ( line )) ! convert text line to array of numbers if ( size ( values ). ne . 0 ) then answer = lcm ( values ) ! function can return error messages, so do not call from WRITE(3f) if ( verbose ) then write ( * , '(i0,\"=lcm([\",*(i0:,\",\"))' , advance = 'no' ) answer , values write ( * , '(\"])\")' ) else write ( * , '(i0)' ) answer endif endif enddo INFINITE else answer = lcm ( values ) ! function can return error messages, so do not call from WRITE(3f) if ( verbose ) then write ( * , '(i0,\"=lcm([\",*(i0:,\",\"))' , advance = 'no' ) answer , values write ( * , '(\"])\")' ) else write ( * , '(i0)' ) answer endif endif end program find_lcm","tags":"","loc":"program/find_lcm.html"},{"title":"find_gcd – easy","text":"Uses M_factor M_strings M_kracken Contents Variables answer ios ios_count line values verbose Source Code find_gcd Variables Type Attributes Name Initial integer :: answer integer :: ios integer :: ios_count = 0 character(len=4096) :: line integer, allocatable :: values (:) logical :: verbose = .false. Source Code program find_gcd Use M_factor , only : gcd => greatest_common_divisor Use M_strings , only : s2vs use M_kracken , only : kracken , igets , lget ! command line parsing implicit none integer :: ios , ios_count = 0 integer , allocatable :: values (:) integer :: answer character ( len = 4096 ) :: line logical :: verbose = . false . !----------------------------------------------------------------------------------------------------------------------------------- call kracken ( 'gcd' , '--help F --version F -verbose F ' ) ! crack command line options call help_usage ( lget ( 'gcd_help' )) ! if help text requested display it and quit call help_version ( lget ( 'gcd_version' )) ! if version information requested display it and quit verbose = lget ( 'gcd_verbose' ) ! get -verbose flag values = igets ( 'gcd_oo' ) ! get numbers from command line !----------------------------------------------------------------------------------------------------------------------------------- if ( size ( values ). eq . 0 ) then ! if did not print a range and no number specified prompt for values INFINITE : do read ( * , '(a)' , iostat = ios ) line ! read line of numbers if ( is_iostat_end ( ios )) then ! if got EOF(end of file) exit loop exit INFINITE elseif ( ios . ne . 0 ) then ! if I/O error reading line read another (could loop on system errors) ios_count = ios_count + 1 if ( ios_count . gt . 1000 ) exit INFINITE ! check to avoid infinite loop if stuck on system I/O error not an EOF cycle INFINITE ! get a new line, had error reading last one endif values = int ( s2vs ( line )) ! convert text line to array of numbers if ( size ( values ). ne . 0 ) then answer = gcd ( values ) ! function can return error messages, so do not call from WRITE(3f) if ( verbose ) then ! write in format \"ANSWER=gcd([VAL(1),VAL(2),VAL(3),...]) write ( * , '(i0,\"=gcd([\",*(i0:,\",\"))' , advance = 'no' ) answer , values write ( * , '(\"])\")' ) else ! just simply write integer answer write ( * , '(i0)' ) answer endif endif enddo INFINITE else answer = gcd ( values ) ! function can return error messages, so do not call from WRITE(3f) if ( verbose ) then write ( * , '(i0,\"=gcd([\",*(i0:,\",\"))' , advance = 'no' ) answer , values write ( * , '(\"])\")' ) else write ( * , '(i0)' ) answer endif endif !----------------------------------------------------------------------------------------------------------------------------------- end program find_gcd","tags":"","loc":"program/find_gcd.html"},{"title":"demo_i_is_prime – easy","text":"Uses M_factor Contents Variables i icount isum n Source Code demo_i_is_prime Variables Type Attributes Name Initial integer :: i integer :: icount = 0 integer :: isum = 0 integer, parameter :: n = 10000 Source Code program demo_i_is_prime use M_factor , only : i_is_prime implicit none integer :: i integer :: icount = 0 integer :: isum = 0 integer , parameter :: n = 10000 do i = 2 , n if ( i_is_prime ( i )) then icount = icount + 1 isum = isum + i write ( * , * ) icount , i endif enddo write ( * , * ) 'number of primes between 2 and ' , n , ' is ' , icount write ( * , * ) 'sum of primes between 2 and ' , n , ' is ' , isum write ( * , * ) i_is_prime ([ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ]) write ( * , * ) all (. not . i_is_prime ([ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ])) write ( * , * ) any (. not . i_is_prime ([ 4 , 6 , 8 , 9 , 10 , 12 , 14 , 15 , 16 , 18 ])) end program demo_i_is_prime","tags":"","loc":"program/demo_i_is_prime.html"},{"title":"demo_greatest_common_divisor – easy","text":"Uses M_factor Contents Variables matrix Subroutines write_matrix writeit writeit_v Source Code demo_greatest_common_divisor Variables Type Attributes Name Initial integer, allocatable :: matrix (:,:) Subroutines subroutine write_matrix (matrix, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: matrix (:,:) integer, intent(in) :: answer subroutine writeit (ii, jj, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: answer subroutine writeit_v (vector, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: vector (:) integer, intent(in) :: answer Source Code program demo_greatest_common_divisor use M_factor , only : gcd => greatest_common_divisor implicit none integer , allocatable :: matrix (:,:) ! SCALAR: call writeit ( 26 , 130 , 26 ) call writeit ( 91 , 390 , 13 ) call writeit ( - 91 , 390 , 13 ) call writeit ( 91 , - 390 , 13 ) call writeit ( - 41 , - 43 , 1 ) call writeit ( - 20 , - 10 , 10 ) call writeit ( 20 , 10 , 10 ) ! VECTOR: call writeit_v ([ 26 , 130 , 91 , 390 ], 13 ) call writeit_v ([ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ], 1 ) call writeit_v ([ - 20 , - 10 , 0 ], 10 ) call writeit_v ([ 20 , 10 , 0 ], 10 ) call writeit_v ([ 26 , 130 ], 26 ) call writeit_v ([ 91 , 390 ], 13 ) call writeit_v ([ - 91 , 390 ], 13 ) call writeit_v ([ 91 , - 390 ], 13 ) call writeit_v ([ - 41 , - 43 ], 1 ) call writeit_v ([ - 20 , - 10 ], 10 ) call writeit_v ([ 20 , 10 ], 10 ) ! MATRIX: matrix = reshape ([ 11 , 22 , 33 , 44 , 55 , 66 ],[ 2 , 3 ]) call write_matrix ( matrix , 11 ) matrix = reshape ([ 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 ],[ 13 , 1 ]) call write_matrix ( matrix , 1 ) matrix = reshape ([ 40 , 80 , 120 , 160 ],[ 2 , 2 ]) call write_matrix ( matrix , 40 ) contains subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer write ( * , '(\"gcd([\",i0,\",\",i0,\"]) produces \",i0,\" which is \",l1)' ) & & ii , jj , gcd ( ii , jj ), gcd ( ii , jj ). eq . answer end subroutine writeit subroutine writeit_v ( vector , answer ) integer , intent ( in ) :: vector (:) integer , intent ( in ) :: answer write ( * , '(\"gcd([\",*(i0:,\",\"))' , advance = 'no' ) vector write ( * , '(\"]) produces \",i0,\" which is \",l1)' ) & & gcd ( vector ), gcd ( vector ). eq . answer end subroutine writeit_v subroutine write_matrix ( matrix , answer ) integer , intent ( in ) :: matrix (:,:) integer , intent ( in ) :: answer write ( * , * ) 'MATRIX SHAPE:' , size ( matrix , dim = 1 ), size ( matrix , dim = 2 ) write ( * , '(\"gcd([\",*(i0:,\",\"))' , advance = 'no' ) matrix write ( * , '(\"]) produces \",i0,\" which is \",l1)' ) & & gcd ( matrix ), gcd ( matrix ). eq . answer end subroutine write_matrix end program demo_greatest_common_divisor","tags":"","loc":"program/demo_greatest_common_divisor.html"},{"title":"demo_prime_factors – easy","text":"Uses M_factor Contents Variables iexp ios iprm nprm number verbose Source Code demo_prime_factors Variables Type Attributes Name Initial integer :: iexp (10) integer :: ios integer :: iprm (10) integer :: nprm integer :: number logical :: verbose = .true. Source Code program demo_prime_factors use M_factor , only : prime_factors implicit none integer :: number integer :: iexp ( 10 ), iprm ( 10 ), nprm logical :: verbose = . true . integer :: ios do write ( * , '(a)' , advance = 'no' ) ' Enter number to be factored: ' read ( * , * , iostat = ios , end = 999 ) number if ( ios . eq . 0 ) then call prime_factors ( number , nprm , iprm , iexp , verbose ) endif enddo 999 continue end program demo_prime_factors","tags":"","loc":"program/demo_prime_factors.html"},{"title":"demo_lcm – easy","text":"Uses M_factor Contents Subroutines writeit writeit_v Source Code demo_lcm Subroutines subroutine writeit (ii, jj, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ii integer, intent(in) :: jj integer, intent(in) :: answer subroutine writeit_v (array, answer) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) integer, intent(in) :: answer Source Code program demo_lcm use M_factor , only : lcm => least_common_multiple implicit none write ( * , * ) 'SCALAR:' call writeit ( 10 , 24 , 120 ) call writeit ( 15 , 30 , 30 ) call writeit ( - 15 , - 30 , 30 ) call writeit ( 15 , - 30 , 30 ) call writeit ( - 15 , 30 , 30 ) write ( * , * ) 'VECTOR:' call writeit_v ([ 10 , 24 ], 120 ) call writeit_v ([ 15 , 30 ], 30 ) call writeit_v ([ - 15 , - 30 ], 30 ) call writeit_v ([ 5 , - 15 , - 40 ], 120 ) call writeit_v ([ 2 , 3 , 4 , 5 ], 60 ) write ( * , * ) 'Special cases:' call writeit_v ([ 15 , 0 ], 0 ) call writeit_v ([ - 15 , 0 ], 0 ) call writeit_v ([ 0 ], 0 ) call writeit_v ([ - 10 ], 10 ) call writeit_v ([ 22 ], 22 ) call writeit_v ([ 0 , 0 ], 0 ) call writeit_v ([ 0 , 0 , 0 , 0 , 0 ], 0 ) call writeit_v ([ 0 , 0 , 0 , - 1 , 0 ], 0 ) call writeit_v ([ 0 , 0 , 0 , 33 , 0 , 3 , 11 ], 0 ) contains subroutine writeit ( ii , jj , answer ) integer , intent ( in ) :: ii , jj integer , intent ( in ) :: answer write ( * , '(\"  For lcm(\",I0,\",\",I0,\") the value is \",I0,\" which is \",L1)' )& & ii , jj , lcm ( ii , jj ), lcm ( ii , jj ). eq . answer end subroutine writeit subroutine writeit_v ( array , answer ) integer , intent ( in ) :: array (:) integer , intent ( in ) :: answer write ( * , '(\"  For lcm([\",*(i0:,1x))' , advance = 'no' ) array write ( * , '(\"]) the value is \",i0,\" which is \",L1)' ) & & lcm ( array ), lcm ( array ). eq . answer end subroutine writeit_v end program demo_lcm","tags":"","loc":"program/demo_lcm.html"},{"title":"test_suite_M_factor – easy","text":"Uses iso_fortran_env M_verify M_verify M_verify M_factor Contents Variables HT Source Code test_suite_M_factor Variables Type Attributes Name Initial integer, parameter :: HT = 9 Source Code program test_suite_M_factor use , intrinsic :: iso_fortran_env , only : ERROR_UNIT use :: M_verify , only : unit_check , unit_check_good , unit_check_bad , unit_check_done , unit_check_start , unit_check_level use :: M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level use M_verify , only : unit_check_stop use :: M_factor implicit none integer , parameter :: HT = 9 unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call unit_check_start ( 'M_BRE' ) call test_greatest_common_divisor call test_i_is_prime call test_least_common_multiple call test_prime_factors !x!call test_gcd !x!call test_gcd_2 call unit_check_stop () end program test_suite_M_factor","tags":"","loc":"program/test_suite_m_factor.html"}]}